<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>

<!--
 - This file is part of the standard developers kit (SDK) for the Power4Flight
 - IntelliJect electronic fuel injection system. You are free to use or modify
 - this file in order to build software that interfaces with, or works with,
 - the Power4Flight IntelliJect system. Copyright Power4Flight 2017-2019.
-->

<Protocol name="eficomms" title="IntelliJect Communications protocol" prefix="efi" api="10" pointer="efiPacket_t" maxSize="1408" packetParameterSuffix="Pkt" packetStructureSuffix="Pkt" file="eficomms" endian="big" comment="
    This ICD describes the communications of the IntelliJect electronic
    fuel injection (EFI) system from [Power4Flight](http://www.power4flight.com/). IntelliJect communicates using packets
    of data transported over asyncrhonous serial, USB, Controller Area Network (CAN), or over a network connection.
    The IntelliJect standard developers kit (SDK) includes C source code for implementing packet encoding and decoding
    routines.">

    <Documentation name="Version" paragraph="2" comment="
    This document is for version 2.0 of the IntelliJect EFI system. The differences between version 1.x and 2.x are mostly
    related to the implementation of the two dimensional tables. The packet format and most of the messages remain
    compatible with the older versions. However the 2D tables format changed substantially - both in terms of the packet,
    and in how the data are used. 2.x tables are now more generic and include information that specifies what independent
    varible is used to index the row and column axes. Soruce code is provided in the SDK to convert from the 1.x to 2.x style
    tables. Any software which reads or modifies the table packets must understand the distinction and take the correct
    action when bridgine software versions."/>

    <Documentation name="Packet format" paragraph="2" file="eficommspacket.txt"/>

    <Structure name="Packet" encode="false" decode="false" file="eficommsProtocol.h" comment="General structure of an IntelliJect EFI packet">
        <Enum name="PacketIds" comment="Values used in the definition of the generic packet">
            <Value name="EFI_PACKET_SYNC0" value="0x57" comment="First synchronization byte for a EFI packet"/>
            <Value name="EFI_PACKET_SYNC0EX" value="0x75" comment="First synchronization byte for a special EFI packet (sdcard record)"/>
            <Value name="EFI_PACKET_SYNC1" value="0xAC" comment="Second synchronization byte for a EFI packet"/>
            <Value name="EFI_PACKET_SYNC1EX" value="0xC8" comment="Second synchronization byte for a special EFI packet (uplink recording)"/>
            <Value name="EFI_PACKET_SYNC1MASK" value="0xEC" comment="Mask to apply to second synchronization byte to remove size bits"/>
            <Value name="EFI_PACKET_SIZE" value="1408" comment="An EFI packet can transport 1408 bytes"/>
            <Value name="EFI_PACKET_HEADER" value="4" comment="An EFI packet has 4 bytes for the header"/>
            <Value name="EFI_PACKET_OVERHEAD" value="8" comment="An EFI packet has 8 bytes of overhead"/>
            <Value name="EFI_PACKET_TYPEBITS" value="6" comment="The number of bits for the type field of an EFI packet"/>
        </Enum>
        <Data name="sync0" inMemoryType="unsigned8" comment="First synchronization byte to indicate a packet may be forthcoming"/>
        <Data name="sync1" inMemoryType="unsigned8" comment="Second synchronization byte, and upper 3 bits of size"/>
        <Data name="sizeLo" inMemoryType="unsigned8" comment="Lower 8 bits of packet size"/>
        <Data name="type" inMemoryType="unsigned8" comment="6 bit packet type, upper 2 bits reserved"/>
        <Data name="data" inMemoryType="unsigned8" array="EFI_PACKET_SIZE+4" comment="Packet data space, plus 4 bytes for crc32"/>
        <Data name="rxstate" inMemoryType="unsigned16" hidden="true" comment="Receive state for processing a receive packet byte by byte, not part of the transmission"/>
    </Structure>

    <Documentation name="Packets over Controller Area Network (CAN)" paragraph="2" comment="
    In the case of transport over a CAN interface the format is modified to work with the 8 byte
    data limit of a CAN frame. For packets containing 8 or less data bytes the packet header and
    crc are discarded. In that case the packet type is included in the CAN ID, the packet
    data size is the CAN frame size, and the CAN layer is responsible for transporting the data without
    corruption.

    The packet type is encoded into the CAN identifier (29 or 11 bit) by specifying a base identifier and
    reserving 6 bits in the identifier for holding the packet type information. See the
    [communications configuration packet](#EFI_PKT_COMMCONFIGURATION) for details of the CAN configuration options. The CAN
    configuration includes three different base identifiers: one for CAN frames IntelliJect sends, one
    for CAN frames IntelliJect receives, and one for broadcast CAN frames that all IntelliJects on the 
    CAN bus can receive.

    If the packet contains more than 8 bytes of data the entire packet (including header and crc)
    are encoded in a series of CAN frames with a special CAN identifier (packet type of zero). This
    process is referred to as *packet-over-CAN*. When using packet-over-CAN the CAN 
    driver software must ensure that frames with the same identifier are transmitted in the
    order they are queued, and that receive frames are processed in the order they appear on
    the CAN bus. If this cannot be guaranteed IntelliJect should be configured to only support
    command and telemetry frames on the CAN bus (which are always 8 bytes or less)."/>

    <Enum name="efiPacketIds" title="Packet identifiers" lookup="true" lookupTitle="true" comment="The list of packet type identifiers.">
        <Value name="EFI_PKT_CANTRANSPORT" title="CAN transport" comment="Identifier for CAN transport of packets with more than 8 bytes of data (packet-over-CAN schema)"/>
        <Value name="EFI_PKT_PUMPCONFIGURATION" title="Fuel pump" comment="Fuel pump configuration information"/>
        <Value name="EFI_PKT_COMMCONFIGURATION" title="Communications" comment="Communications configuration information"/>
        <Value name="EFI_PKT_SENSORCONFIGURATION" title="Sensor" comment="Sensor configuration information for a single sensor"/>
        <Value name="EFI_PKT_THROTTLECONFIGURATION" title="Throttle" comment="Throttle configuration information"/>
        <Value name="EFI_PKT_RESERVED" hidden="true"/>
        <Value name="EFI_PKT_INJECTORCONFIGURATION" title="Injector" comment="Injector configuration information"/>
        <Value name="EFI_PKT_RPMCONTROLLER" title="RPM controller" comment="RPM Controller configuration"/>
        <Value name="EFI_PKT_ENGINEWEAR" title="Engine wear" comment="Engine wear information"/>
        <Value name="EFI_PKT_TABLE" title="Table data" comment="Table settings for a single table"/>
        <Value name="EFI_PKT_TABLEVALUE" title="Table data value" comment="Table single value"/>
        <Value name="EFI_PKT_RESERVED1" hidden="true"/>
        <Value name="EFI_PKT_SOFTWAREINFO" title="Software version" comment="Software version information"/>
        <Value name="EFI_PKT_STICKY_ERRORS" title="Sticky error telemetry" comment="Sticky error information"/>
        <Value name="EFI_PKT_ENABLE" title="Enable/disable command" comment="User enables"/>
        <Value name="EFI_PKT_USERTHROTTLE" title="Throttle command" comment="Throttle command"/>
        <Value name="EFI_PKT_RPMCOMMAND" title="RPM command" comment="RPM command"/>
        <Value name="EFI_PKT_REQUEST" title="Packet request command" comment="Request for multiple configuration packets"/>
        <Value name="EFI_PKT_TELEMETRYTIME" title="Time telemetry" comment="Telemetry time information"/>
        <Value name="EFI_PKT_TELEMETRYFAST" title="Fast telemetry" comment="Fast telemetry"/>
        <Value name="EFI_PKT_TELEMETRYSENSORS" title="Sensors telemetry" comment="Telemetry information for sensors"/>
        <Value name="EFI_PKT_TELEMETRYSENSORS2" title="Sensors2 telemetry" comment="Telemetry2 information for sensors"/>
        <Value name="EFI_PKT_TELEMETRYFUEL" title="Fuel consumption telemetry" comment="Fueling information"/>
        <Value name="EFI_PKT_TELEMETRYSLOW" title="Slow telemetry" comment="Miscellanious slow telemetry"/>
        <Value name="EFI_PKT_TELEMETRYCPU" title="CPU telemetry" comment="Telemetry about the CPU performance"/>
        <Value name="EFI_PKT_TELEMETRYINJECTOR" title="Injector telemetry" comment="Telemetry about the injectors"/>
        <Value name="EFI_PKT_TELEMETRYERRORS" title="Dynamic error telemetry" comment="Dynamic error information"/>
        <Value name="EFI_PKT_NACK" title="Not-acknowledge report" comment="Packet not-acknowledge"/>
        <Value name="EFI_PKT_UNLOCK" title="Unlock command" comment="Configuration unlock"/>
        <Value name="EFI_PKT_LOCKCONTROL" title="Locking" comment="Configuration locking for the system"/>
        <Value name="EFI_PKT_RESET" title="Reset report" comment="Report or command a reset of the system"/>
        <Value name="EFI_PKT_FILE" title="File name" comment="File name for the settings file"/>
        <Value name="EFI_PKT_COMMENT" title="Comment" comment="Configuration comment"/>
        <Value name="EFI_PKT_STORAGE" title="Storage command" comment="Storage configuration command"/>
        <Value name="EFI_PKT_HARDWAREINFO" title="Hardware version" comment="Information about the hardware"/>
        <Value name="EFI_PKT_TELEMETRYFASTSUM" title="Fast telemetry summary" comment="A super packet containing all the fast telemetry"/>
        <Value name="EFI_PKT_TELEMETRYSLOWSUM" title="Slow telemetry summary" comment="A super packet containing all the slow telemetry"/>
        <Value name="EFI_PKT_BOOTLOADER" title="Bootloader command and report" comment="Bootloader control packet"/>
        <Value name="EFI_PKT_TELEMETRYSENSORS3" title="Sensors3 telemetry" comment="Telemetry3 information for sensors"/>
        <Value name="EFI_PKT_CONFIGHASH" title="Validation" comment="Send this packet to flag the current configuration as valid"/>
        <Value name="EFI_PKT_TELEMETRYCOMMS" title="Telemetry about communications" comment="Telemetry about communications performance and errors"/>
        <Value name="EFI_PKT_OSCILLOSCOPE_SETUP" title="Oscilloscope setup packet" comment="Oscilloscope setup packet"/>
        <Value name="EFI_PKT_OSCILLOSCOPE_DATA" title="Oscilloscope data packet" comment="Oscilloscope data packet"/>
        <Value name="EFI_PKT_DEBUG" title="IntelliJect debug packet" comment="Packet used for debug"/>
        <Value name="EFI_PKT_TESTMODE" title="IntelliJect test mode packet" comment="Packet used for testing"/>
        <Value name="EFI_PKT_TELEMETRYSDCARD" title="Telemetry about the SD card" comment="Telemetry about the SD card"/>
        <Value name="EFI_PKT_FUELUSED" title="Fuel used" comment="Packet used to set or report the fuel used"/>
        <Value name="EFI_PKT_TELEMETRYAUTOFUEL" hidden="true" title="Automatic fuel determination" comment="Packet used for reporting autofuel results"/>
        <Value name="EFI_PKT_TELEMETRYSENSORS4" title="Sensors4 telemetry" comment="Telemetry4 information for sensors"/>
        <Value name="EFI_PKT_ENGINEWEAREXT" title="Extended engine wear" comment="Extended engine wear information"/>
        <Value name="EFI_PKT_MAINTENANCECONFIGURATION" title="Maintenance schedule" comment="Maintenance schedule configuration"/>
        <Value name="EFI_PKT_MAINTENANCESTATUS" title="Maintenance status" comment="Maintenance status"/>
        <Value name="EFI_PKT_LOGENTRY" title="Engine logbook" comment="Engine log entry"/> 
        <Value name="EFI_PKT_CRANKSENSETIMING" title="Crank wheel timing" comment="Crank wheel timing details"/>
        <Value name="EFI_PKT_SDCARDJOURNAL" title="SD card journal information" comment="SD Card journal information"/>
        <Value name="EFI_PKT_INTERRUPTDETAILS" title="Interrupt details" comment="Detailed information about interrupts"/>
        <Value name="EFI_PKT_COOLINGCONFIGURATION" title="Cooling" comment="Cooling configuration information"/>
        <Value name="EFI_PKT_NEWENGINECONFIGURATION" title="Engine" comment="Engine configuration information for api 7 and later"/>
        <Value name="EFI_PKT_TELEMETRYGCU" title="GCU Telemetry" comment="Telemetry information for the generator control unit"/>
        <Value name="EFI_PKT_TELEMETRYEXTENDEDOUTPUTS" title="Extended outputs telemetry" comment="Telemetry for injector3, spark2, and spark3"/>
        <Value name="EFI_PKT_TELEMETRYOILINJ" title="Oil Injection Telemetry" comment="Telemetry for the oil injection system"/>
        <Value name="EFI_PKT_MAXID" value="EFI_PKT_TELEMETRYOILINJ" hidden="true" ignoreLookup="true" comment="Maximum packet ID to or from an EFI using this version of the protocol"/>
        <Value name="EFI_PKT_SDBLOCKDATA" value="253" hidden="true" ignoreLookup="true" comment="This packet appears at the start of each block (except the journal) in SD cards"/>
        <Value name="EFI_PKT_SENSORAUTOOFFSET" value="254" hidden="true" ignoreLookup="true" comment="Packet for storing sensor offsets for auto-corrected sensors"/>
        <Value name="EFI_PKT_QUICKRESTART" value="255" hidden="true" ignoreLookup="true" comment="Packet for immediate spark and inject needed to keep an engine running through a system reset"/>
    </Enum>

    <Documentation comment="---"/>
    <Documentation name="Packets for commanding IntelliJect at runtime" paragraph="1"
        comment="Use these packets to send commands at engine runtime. They are 8 bytes or less so they can be transmitted in a single CAN frame. Reception of commands typically do not generate a reply; instead the command reception can be verified by observing the relevant information in the telemetry output."/>

    <Packet name="Enable" title="EFI Enable" ID="EFI_PKT_ENABLE"
        comment="Enable/disable command. Use this packet to shut down the engine by clearing `userEnable` or to selectively disable the first or second spark output by clearing `spark1Enable` or `spark2Enable`. The EFI will boot up with all the enables set. The current enable status is visible in the [fast telemetry](#EFI_PKT_TELEMETRYFAST) packet.">
        <Data name="ioEnable" inMemoryType="unsigned8" encodedType="bitfield1" comment="Global enable based on physical input. This enable cannot be changed by this packet."/>
        <Data name="userEnable" inMemoryType="unsigned8" encodedType="bitfield1" comment="User global enable. Set to zero to disable the engine."/>
        <Data name="spark1Enable" inMemoryType="unsigned8" encodedType="bitfield1" comment="User enable for spark1. Set to zero to disable spark 1."/>
        <Data name="spark2Enable" inMemoryType="unsigned8" encodedType="bitfield1" comment="User enable for spark2. Set to zero to disable spark 2."/>
        <Data name="spark3Enable" inMemoryType="unsigned8" encodedType="bitfield1" comment="User enable for spark3. Set to zero to disable spark 3."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="crankEnable" inMemoryType="unsigned8" encodedType="bitfield1" comment="If set command the GCU system to crank for start, if clear command the GCU system to stop cranking. Cranking status will be visible in the GCU telemetry packet."/>
        <Data name="oilInjPrime" inMemoryType="unsigned16" encodedType="unsigned8" default="0" scaler="0.05" comment="Number of oil injection pulses to deliver to prime the system. This only applies if an injector is configured for oil injection. Use zero to stop the priming operation. Priming will be ignored if the system is not enabled. Priming will be stopped if the engine starts running."/>
    </Packet>

    <Packet name="UserThrottle" title="User Throttle Command" ID="EFI_PKT_USERTHROTTLE" comment=
        "Send a user throttle command. The actual throttle used by the EFI will depend upon its configuration and the status of the throttle input sensors. This command will be ignored if the throttle configuration does not have `efiDrivesThrottle` set. The current throttle status (input, output, source) are visible in the [fast telemetry](#EFI_PKT_TELEMETRYFAST) packet.">
        <Data name="throttle" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="The user commanded throttle in percent"/>
    </Packet>

    <Packet name="RPMCommand" title="User RPM Command" ID="EFI_PKT_RPMCOMMAND" comment="Send a RPM command; which will engage the RPM controller. The RPM command will be ignored if the throttle configuration does not have `efiDrivesThrottle` set. The RPM controller can be disengaged by sending a [user throttle](#EFI_PKT_USERTHROTTLE) command. The current RPM command value and command source is visible in the [slow telemetry](#EFI_PKT_TELEMETRYSLOW) packet.">
        <Data name="rpmcmd" inMemoryType="float32" encodedType="unsigned16" scaler="2" comment="Engine speed command in revolutions per minute"/>
    </Packet>

    <Structure name="Date" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="Calendar date information">
        <Data name="day" inMemoryType="unsigned8" encodedType="bitfield5" comment="The day of the month from 1 to 31"/>
        <Data name="month" inMemoryType="unsigned8" encodedType="bitfield4" comment="The month of the year from 1 (January) to 12 (December)"/>
        <Data name="year" inMemoryType="unsigned16" encodedType="bitfield7" min="2000" comment="The year (AD) of the date"/>
    </Structure>

    <Structure name="DateTime" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="Date and time information">
        <Data name="jiffytime" inMemoryType="unsigned32" encodedType="unsigned24" comment="10s of milliseconds of the day from 0 to 8640000"/>
        <Data name="day" inMemoryType="unsigned8" encodedType="bitfield5" comment="The day of the month from 1 to 31"/>
        <Data name="month" inMemoryType="unsigned8" encodedType="bitfield4" comment="The month of the year from 1 (January) to 12 (December)"/>
        <Data name="year" inMemoryType="unsigned16" encodedType="bitfield7" min="2000" comment="The year (AD) of the date"/>
    </Structure>

    <Documentation comment="---"/>
    <Documentation name="Packets for manipulating IntelliJect" paragraph="1"
        comment="Use these packets to send commands to the EFI. These commands are not typically used for normal engine running. The response to these packets will depend on the state of the engine, the lock configuration, and the lock level. For more information about configuration locking see the [lock control](#EFI_PKT_LOCKCONTROL) packet."/>

    <Enum name="efiunlocklevels" title="EFI lock levels" comment="Different levels of locking/unlocking">
        <Value name="EFI_LCK_LOCKED" comment="EFI configuration is locked, unlock must be issued to change anything"/>
        <Value name="EFI_LCK_PARTIAL_UNLOCKED" comment="EFI configuration partially unlocked, some data may still be protected"/>
        <Value name="EFI_LCK_PASSWORD_UNLOCKED" comment="EFI configuration is fully unlocked, all data are unprotected"/>
    </Enum>

    <Structure name="ConfigBits" comment="One bit for every configuration packet that can be sent, requested, or stored.">
        <Data name="sensors" inMemoryType="bitfield16" encodedType="bitfield16" comment="One bit for each of the sensors. The least significant bit is the first sensor."/>
        <Data name="reservedbits" inMemoryType="bitfield3" comment="Remaining bits for future expansion"/>
        <Data name="cooling" inMemoryType="bitfield1" comment="The cooling configuration"/>
        <Data name="newengine" inMemoryType="bitfield1" comment="The new engine configuration"/>
        <Data name="sdjournal" inMemoryType="bitfield1" comment="The SD Card journal data"/>
        <Data name="wear" inMemoryType="bitfield1" comment="The engine wear data"/>
        <Data name="logbook" inMemoryType="bitfield1" comment="The logbook data"/>
        <Data name="maintenancestatus" inMemoryType="bitfield1" comment="The maintenance status data"/>
        <Data name="maintenanceconfig" inMemoryType="bitfield1" comment="The maintenance configuration data"/>
        <Data name="scopesetup" inMemoryType="bitfield1" comment="The oscilloscope setup data"/>
        <Data name="confighash" inMemoryType="bitfield1" comment="The configuration hash data"/>
        <Data name="pump" inMemoryType="bitfield1" comment="The fuel pump configuration"/>
        <Data name="comms" inMemoryType="bitfield1" comment="The communications configuration"/>
        <Data name="throttle" inMemoryType="bitfield1" comment="The throttle configuration"/>
        <Data name="reservedbit" inMemoryType="bitfield1" comment="A reserved bit for future expansion"/>
        <Data name="injector" inMemoryType="bitfield1" comment="The injector configuration"/>
        <Data name="rpmcontroller" inMemoryType="bitfield1" comment="The rpm controller configuration"/>
        <Data name="lockcontrol" inMemoryType="bitfield1" comment="The lock control information"/>
        <Data name="softwareinfo" inMemoryType="bitfield1" comment="The software information data"/>
        <Data name="resetinfo" inMemoryType="bitfield1" comment="The reset report data"/>
        <Data name="file" inMemoryType="bitfield1" comment="The file data"/>
        <Data name="comment" inMemoryType="bitfield1" comment="The comment data"/>
        <Data name="hardwareinfo" inMemoryType="bitfield1" comment="The hardware information data"/>
        <Data name="tables" inMemoryType="bitfield24" comment="One bit for each of the tables. The least significant bit is the first table."/>
        <Data name="reservedbits2" inMemoryType="bitfield19" comment="More bits for future expansion"/>
        <Data name="tables2" inMemoryType="bitfield13" comment="One bit for each of the tables above table 23. The least significant bit is table 24."/>
    </Structure>

    <Packet name="ConfigRequest" title="Request Configuration Data" ID="EFI_PKT_REQUEST" comment="Use this packet to request one or more configuration and status packets from the EFI. After receiving this packet the EFI will transmit a response packet for every bit which is set. If the EFI is configured to hide configuration data the response packet(s) may be a [nack](#EFI_PKT_NACK) rather than the desired packet(s).">
        <Data name="bits" struct="ConfigBits" comment="One bit for every configuration packet"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield3" comment="More bits for future expansion"/>
        <Data name="api" inMemoryType="unsigned8" constant="geteficommsApi()" encodedType="bitfield5" comment="Application programming interface number of the protocol doing the requesting. Changes to the ICD will increment this number."/>
    </Packet>

    <Packet name="smallConfigRequest" encode="false" hidden="true" redefine="ConfigBits" ID="EFI_PKT_REQUEST" comment="Use this packet to request one or more configuration and status packets from the EFI. If the EFI receives this packet it will assume the requesting system is using version 1.x software and will convert tables.">
        <Data name="sensors" inMemoryType="bitfield16" encodedType="bitfield16" comment="One bit for each of the sensors. The least significant bit is the first sensor."/>
        <Data name="reservedbits" inMemoryType="bitfield3" comment="Remaining bits for future expansion"/>
        <Data name="cooling" inMemoryType="bitfield1" comment="The cooling configuration"/>
        <Data name="newengine" inMemoryType="bitfield1" comment="The new engine configuration"/>
        <Data name="sdjournal" inMemoryType="bitfield1" comment="The SD Card journal data"/>
        <Data name="wear" inMemoryType="bitfield1" comment="The engine wear data"/>
        <Data name="logbook" inMemoryType="bitfield1" comment="The logbook data"/>
        <Data name="maintenancestatus" inMemoryType="bitfield1" comment="The maintenance status data"/>
        <Data name="maintenanceconfig" inMemoryType="bitfield1" comment="The maintenance configuration data"/>
        <Data name="scopesetup" inMemoryType="bitfield1" comment="The oscilloscope setup data"/>
        <Data name="confighash" inMemoryType="bitfield1" comment="The configuration hash data"/>
        <Data name="pump" inMemoryType="bitfield1" comment="The fuel pump configuration"/>
        <Data name="comms" inMemoryType="bitfield1" comment="The communications configuration"/>
        <Data name="throttle" inMemoryType="bitfield1" comment="The throttle configuration"/>
        <Data name="reservedbit" inMemoryType="bitfield1" comment="A reserved bit for future expansion"/>
        <Data name="injector" inMemoryType="bitfield1" comment="The injector configuration"/>
        <Data name="rpmcontroller" inMemoryType="bitfield1" comment="The rpm controller configuration"/>
        <Data name="lockcontrol" inMemoryType="bitfield1" comment="The lock control information"/>
        <Data name="softwareinfo" inMemoryType="bitfield1" comment="The software information data"/>
        <Data name="resetinfo" inMemoryType="bitfield1" comment="The reset report data"/>
        <Data name="file" inMemoryType="bitfield1" comment="The file data"/>
        <Data name="comment" inMemoryType="bitfield1" comment="The comment data"/>
        <Data name="hardwareinfo" inMemoryType="bitfield1" comment="The hardware information data"/>
        <Data name="tables" inMemoryType="bitfield24" encodedType="bitfield24" comment="One bit for each of the tables. The least significant bit is the first table."/>
        <Data name="reservedbits2" inMemoryType="bitfield20" default="0" comment="More bits for future expansion"/>
        <Data name="tables2" inMemoryType="bitfield12" default="0" encodedType="bitfield8" comment="One bit for each of the tables above table 23. The least significant bit is table 24."/>
    </Packet>

    <Packet name="Unlock" title="Unlock Command" ID="EFI_PKT_UNLOCK"
            comment="Send this packet to unlock the EFI so configuration data can be changed (or viewed if hidden). For password locked configurations, if the password is lost you can use the string 'CLEAR ALL DATA'. This will allow the EFI to be password unlocked, but will also reset the EFI to defaults, clearing all existing configuration data from both user and factory storage. Note that the 'CLEAR ALL DATA' password cannot be used if the engine is running, in which case a [nack](#EFI_PKT_NACK) will be generated. After receiving this packet the EFI will send this packet back to the user, to report the current lock status. Anytime the EFI sends this packet the password field will be empty. The lock status is always visible in the [cpu telemetry](#EFI_PKT_TELEMETRYCPU) packet. The cpu telemetry packet also indicates if unlocking will require a password.

            This packet can be used to lock the EFI by requesting an unlock level which is lower than the current level. In that case the password is not needed.">
        <Data name="reserved" inMemoryType="null" encodedType="bitfield6"/>
        <Data name="unlockLevel" inMemoryType="bitfield2" comment="For packets going to the EFI this is the desired unlock level. For packets coming from the EFI this the current unlock level."/>
        <Data name="password" inMemoryType="string" array="32" comment="Password used to unlock. This password must match the password used in the lock configuration. If the password is incorrect the EFI will respond with nack. When the EFI sends this packet the password field will be empty."/>
    </Packet>

    <Packet name="ResetCmd" title="Reset Command" ID="EFI_PKT_RESET"
        comment="Packet used to command an EFI reset. This is primarily used to reset the EFI into bootloader mode for firmware update. This packet is also used for software development testing and to test the behavior of the engine
        during EFI reset. This packet will not be obeyed unless the unlock level is [`EFI_LCK_PASSWORD_UNLOCKED`](#efiunlocklevels), *or* the engine is not running and the reset requested is `bootloaderReset`.">
        <Data name="watchdogReset" inMemoryType="bitfield1" comment="If set perform a reset by entering an infinite loop so that the watchdog triggers a reset."/>
        <Data name="softwareReset" inMemoryType="bitfield1" comment="If set perform a software reset"/>
        <Data name="invalidAddressReset" inMemoryType="bitfield1" comment="If set perform a memory write to an invalid address in order to trigger a memory exception reset"/>
        <Data name="unalignedAddressReset" inMemoryType="bitfield1" comment="If set perform a memory write to an unaligned address in order to trigger a unaligned exception reset"/>
        <Data name="divideByZeroReset" inMemoryType="bitfield1" comment="If set perform a integer divide by zero in order to trigger an exception reset"/>
        <Data name="floatDivideByZeroReset" inMemoryType="bitfield1" comment="If set perform a floating point divide by zero in order to trigger an floating point interrupt reset"/>
        <Data name="bootloaderReset" inMemoryType="bitfield1" comment="If set perform a reset to enter into bootloader mode for firmware update."/>
        <Data name="safemodereset" inMemoryType="bitfield1" comment="If set perform a reset that results in safe mode"/>
        <Data name="extraVerification" inMemoryType="unsigned32" constant="0xABCD8765" checkConstant="true" comment="This field must be set to `0xABCD8765` or the packet will be ignored"/>
    </Packet>

    <Packet name="StorageLong" ID="EFI_PKT_STORAGE" parameterInterface="true"
        comment="Commands for manipulating storage. The EFI maintains two storage locations for non-volatile configuration data. The user storage data is always updated whenever the configuration is changed. Any configuration data which is not present in the user storage will be supplied by the factory storage when the EFI starts up. Factory storage is intended to hold the configuration as it left the factory, providing a way for users to revert to the original configuration. Factory configuration data is stored in on-chip flash, and will take several seconds to change, therefore factory storage cannot be changed while the engine is running.

        Storage commands that affect the EEPROM or flash (i.e. non-sdcard commands) will not be obeyed unless the unlock level is [`EFI_LCK_PASSWORD_UNLOCKED`](#efiunlocklevels). In addition any command which changes the factory storage will not be obeyed if the engine is running. Note that clearing the storage will not clear the engine wear information. If this command alters configuration data the EFI will send the configuration packets.

        The storage command is also used with the SD card. SD card storage commands can be sent when the engine is running, and do not require the system to be unlocked. To read a record from the SD card send the command `efiStorageTransferSD` with the record number to be read. The progress of the SD transfer can be monitored with the SD card telemetry packet. When the transfer is complete this packet will be sent from the EFI with the command `efiStorageStopTransferSD` to indicate the transfer is complete. You can also stop the transfer by sending the command `efiStorageStopTransferSD`.">

        <Enum name="efiStorageCmds" title="Storage Commands" comment="Enumeration of storage commands">
            <Value name="efiStorageClearAll" comment="Use this command to clear user and factory settings, causing the EFI to revert to hard-coded default settings. This will trigger a send of all configuration data."/>
            <Value name="efiStorageRestoreFactory" comment="Use this command to clear any user settings, causing the EFI to revert to any stored settings in the factory storage space. This will trigger a send of all configuration data."/>
            <Value name="efiStorageSaveFactory" comment="Use this command to save the current settings to factory storage. This will also clear the user storage, except for the engine wear information."/>
            <Value name="efiStorageSetupSD" comment="Use this command to setup the SD card, which lays out the root directory filesystem."/>
            <Value name="efiStorageFormatSD" comment="Use this command to format the SD card."/>
            <Value name="efiStorageEraseSD" comment="Erase the SD card."/>
            <Value name="efiStorageTransferSD" comment="Transfer a record from the SD card."/>
            <Value name="efiStorageStopTransferSD" comment="Stop Transferring a record from the SD card."/>
        </Enum>

        <Data name="command" enum="efiStorageCmds" encodedType="unsigned8" comment="The storage command to execute"/>
        <Data name="aborted" inMemoryType="unsigned8" encodedType="bitfield1" comment="If the command is `efiStorageStopTransferSD` this flag will be set if the transfer was stopped because of a problem with the SD card."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield7"/>
        <Data name="sdrecord" inMemoryType="unsigned16" comment="The record identifier for the `efiStorageTransferSD` command. This must be a valid record in the SD card journal."/>
    </Packet>

    <Packet name="Storage" redefine="StorageLong" ID="EFI_PKT_STORAGE" parameterInterface="true"
        comment="Short version of the storage command. This version can be used for all commands except the `efiStorageTransferSD`">
        <Data name="command" enum="efiStorageCmds" encodedType="unsigned8" comment="The storage command to execute"/>
    </Packet>

    <Packet name="FuelUsed" title="Fuel and oil used" ID="EFI_PKT_FUELUSED" parameterInterface="true" comment="Use this packet to set or request the total fuel and oil used. The fuel and oil totalizers start at zero when the EFI boots up and increases as the engine runs. The fuel used is also reported in the fuel telemetry packet. The oil used is also reported in the oil injection telemetry packet. Send this packet with zero length to request the fuel and oil used.">
        <Data name="fuelConsumption" inMemoryType="float32" encodedType="float16:10" comment="Fuel consumption in grams since the system turned on."/>
        <Data name="oilConsumption" inMemoryType="float32" encodedType="float16:10" default="0" comment="Oil consumption in grams since the system turned on."/>
    </Packet>

    <Packet name="MaintenanceStatus" title="Maintenance status" ID="EFI_PKT_MAINTENANCESTATUS" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="Set or request the maintenance status. To request the status send this packet with zero length. If unlocked you can send this packet to overwrite the maintenance status (except for `engineSerial`). To change the `engineSerial` `setEngineSerial` must be set and IntelliJect must be unlocked. Typically you do not send this packet to change the maintenance status, instead you use the PerformMaintenance packet for that purpose.">
        <Data name="domaintenance" inMemoryType="bitfield1" constant="0" checkConstant="true" comment="This bit must be clear, if not clear than this packet is interpreted as a PerformMaintenance packet. This bit will never be set when this packet comes from IntelliJect."/>
        <Data name="setEngineSerial" inMemoryType="bitfield1" comment="Set this bit when sending to IntelliJect to change the engine serial number. This change can only be performed if IntelliJect is unlocked. This bit will never be set when this packet comes from IntelliJect."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield1"/>
        <Data name="numItems" inMemoryType="unsigned8" encodedType="bitfield5" comment="The number of maintenance status items in this packet"/>
        <Data name="engineSerial" inMemoryType="unsigned32" comment="The engine serial number. This can only be changed if IntelliJect is unlocked and `setEngineSerial` is set."/>
        <Structure name="MaintenanceItemStatus" array="maxMaintenanceItems" variableArray="numItems" comment="List of maintenance item status">
            <Data name="triggered" inMemoryType="bitfield1" comment="This bit is set if the maintenance item has elapsed."/>
            <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
            <Data name="index" inMemoryType="unsigned8" encodedType="bitfield5" comment="The index number of this maintenance item status. the index number matches the index from the maintenance schedule configuration."/>
            <Data name="servicetime" struct="DateTime" comment="The date and time when this maintenance item was last serviced. This field can only be changed with the `DoMaintenance` command"/>
            <Data name="lastdone" inMemoryType="unsigned32" comment="The last time this maintenance item was done, zero if never."/>
            <Data name="name" inMemoryType="string" array="maxNameCharacters" comment="Name of the person who did the most recent maintenance."/>
        </Structure>
    </Packet>

    <Packet name="PerformMaintenance" title="Perform maintenance" ID="EFI_PKT_MAINTENANCESTATUS" comment="Send this packet to IntelliJect to perform a single maintenance item. Performing maintenance means clearing the triggered status, updating the `lastdone` and `name` fields on the maintenance status, and adding a log entry. This packet is never sent by IntelliJect, the response will always be the MaintenanceStatus packet, followed by a LogEntry packet.">
        <Data name="domaintenance" inMemoryType="bitfield1" constant="1" checkConstant="true" comment="Set this bit when sending to IntelliJect to indicate that this maintenance item has been performed. This bit will never be set when this packet comes from IntelliJect."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="index" inMemoryType="unsigned8" encodedType="bitfield5" comment="The index number of the maintenance item that is being performed. the index number matches the index from the maintenance schedule configuration."/>
        <Data name="servicetime" struct="DateTime" comment="The date and time when this maintenance item was serviced."/>
        <Data name="name" inMemoryType="string" array="maxNameCharacters" comment="Name of the person who did the maintenance."/>
        <Data name="description" inMemoryType="string" array="EFI_PACKET_SIZE - maxNameCharacters - 7" comment="The text that goes into the log as part of performing this maintenance."/>
    </Packet>

    <Packet name="LogEntry" title="Engine Logbook Entry" ID="EFI_PKT_LOGENTRY" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="Log entry packet used to request, add, or change entries in the digital engine logbook. The logbook consists of a series of entries, each contained in a single packet. Each log entry contains a, `date`, `name`, and `description` text. In addition each log entry has an `index` that simply identifies the location of the entry in the logbook.

    The interpretation of the log entry packet depends on the value of the `cmd` field, and on whether the packet was sent to, or received from, the EFI. When requesting a specific log entry, requesting the number of log entries, or deleting a log entry; you only need to send the first two bytes, identifying the log entry by its index. Note that if a log entry is deleted the indices of the log entries above the deleted entry will be changed so that the list of indices alays starts at zero and ends at 1 less than the number of entries.

    When requesting the number of log entries the EFI will respond with the two byte form of this packet, with `cmd` set to `numLogEntries` and `index` giving the number of log entries. When requesting a log entry the EFI will respond with the requested entry and the `cmd` value set to `logEntry`. When deleting a log entry the EFI will respond with the two byte form of this packet, with the `cmd` set to `deleteLogEntry` and the `index` set to the deleted entry's index.

    To add a new log entry send this packet with `cmd` set to `logEntry` and `index` greater than the or equal to the `numLogEntries`. The EFI will respond by echoing the new log entry. To change an existing log entry set `index` equal to the entry to change. The EFI will first delete the `index` entry (resetting all the indices of later entries) and then append the updated entry to the logbook. In this case the EFI will respond as through two separate commands were sent: a delete command followed by a new log entry.

    The logbook is stored onboard IntelliJect in 128Kbytes of flash. If each entry uses the maximum amount of text there is space for at least 127 entries. Most entries will have less than the maximum text so it should be possible to have many more than 127 entries. Because the logbook is stored in flash deleting or changing an entry requires zero-ing that flash location and re-writing the entry further on. Enough log entries, deletions, or edits, will use up or fragment the log storage space until no more entries can be made. In that case log additions will result in a nack. Use the command `eraseLogBook` to completely erase the log; at which point you can reload it without framentation, and/or remove older log entries to make room for new ones. The log cannot be changed while the engine is running, attempting to do so will result in a nack.

    Adding a new log entry does not require IntelliJect to be unlocked. However deleting or changing a log entry does require IntelliJect to be unlocked. The log follows the same access restrictions as the maintenance schedule.">

        <Enum name="LogEntryCommands" comment="Commands for the log entry packet.">
            <Value name="logEntry" comment="A new or existing log entry"/>
            <Value name="requestLogEntry" comment="Request a specific log entry"/>
            <Value name="deleteLogEntry" comment="Delete a log entry"/>
            <Value name="numLogEntries" comment="Request the number of log entries."/>
            <Value name="eraseLogBook" comment="Erase the entire log."/>
        </Enum>

        <Enum name="MaxLogEntries" comment="Maximum number of log entries.">
            <Value name="maxLogEntries" value="1022" comment="Maximum number of log entries that can be supported."/>
        </Enum>

        <Data name="cmd" enum="LogEntryCommands" encodedType="bitfield3" comment="Command for the log entry packet. The interpretation of the command depends . Use `logEntry` or `requestLogEntry` to request a log. Use `deleteLogEntry` to delete a log. Use `numLogEntries` to request the number of log entries. The log is identified by either the `time` value, of if the `time` is invalid, then by the `index`."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield3"/>
        <Data name="index" inMemoryType="unsigned16" encodedType="bitfield10" comment="The index number for this log."/>
        <Data name="time" struct="DateTime" comment="The date and time of the log entry."/>
        <Data name="name" inMemoryType="string" array="maxNameCharacters" comment="Name of the person who entered the log entry."/>
        <Data name="description" inMemoryType="string" array="EFI_PACKET_SIZE - maxNameCharacters - 7" comment="The log entry text."/>
    </Packet>

    <Packet name="LogEntryCommand" parameterInterface="true" hidden="true" ID="EFI_PKT_LOGENTRY" comment="Command packet for a log entry.">
        <Data name="cmd" enum="LogEntryCommands" encodedType="bitfield3" comment="Command for the log entry packet. Use 'logEntry' or `requestLogEntry` to request a log. Use `deleteLogEntry` to delete a log. Use `numLogEntries` to request the number of log entries. The log is identified by either the `time` value, of if the `time` is invalid, then by the `index`."/>
        <Data name="index" inMemoryType="unsigned16" encodedType="bitfield13" comment="The index number that goes with the command."/>
    </Packet>
    
    <Packet name="SDCardJournal" ID="EFI_PKT_SDCARDJOURNAL" comment="This packet reports the SD card journal, which is used to track information written to the SD card. The journal is stored on the card and cannot be changed with this packet. The journal can be requested from the EFI by sending this packet with zero length. If no card is installed, or the card has a problem, the journal will contain no records.">
        <Enum name="NumJournal">
            <Value name="maxJournalEntries" value="81" comment="Maximum number of journal entries that can fit in a 512 byte packet"/>
        </Enum>
        <Data name="sdcardtm" struct="TelemetrySDCard" comment="SD card telemetry information. The only field from this telemetry that is used for journaling is `numDataBlocks`."/>
        <Data name="numBlocksInVolume" inMemoryType="unsigned32" comment="The number of data blocks the card volume can hold, including the journal blocks."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield9"/>
        <Data name="numRecords" inMemoryType="unsigned8" encodedType="bitfield7" comment="Number of records in the journal. This may be less than the number of records on the card."/>
        <Structure name="journal" array="maxJournalEntries" variableArray="numRecords" comment="Journal information for records of data on the SD card">
            <Data name="record" inMemoryType="unsigned16" comment="The record identifier."/>
            <Data name="lastBlock" inMemoryType="unsigned32" comment="The last 512 byte block written for this record, relative to the start of the card volume. The first and last blocks on the card contains the journal."/>
        </Structure>
    </Packet>

    <Documentation comment="---"/>
    <Documentation name="Packets used to configure IntelliJect" paragraph="1" comment=
        "These packets are used to change or report the configuration. Configuration information can be
         queried by sending a zero length packet, or a packet with a single byte specifying which table or sensor to request.
         Configuration packets can be longer than 8 bytes and are transported over CAN using the packet-over-CAN schema. 
         When changing configuration information the packets are always sent back to the sender as confirmation of their 
         receipt. In some cases the echoed packet contents may be modified to correct inconsistencies in the data."/>

    <Packet name="File" title="File Information" ID="EFI_PKT_FILE" comparefile="compare/eficompareutil" printfile="compare/efiprintutil"
            comment="The file packet gives the name of a file. This is typically used to store the name of the file that was
                     used to configure this EFI. The file name is not used by the EFI, it is provided as a convenient means of configuration management.">
        <Data name="reserved" inMemoryType="null" encodedType="unsigned8" array="8"/>
        <Data name="date" struct="Date" comment="The date when the file configuration was sent"/>
        <Data name="filename" inMemoryType="string" array="128" comment="The name of the file used to load configuration."/>
    </Packet>

    <Packet name="Comment" ID="EFI_PKT_COMMENT" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="This packet gives a user comment to describe the configuration. The comment is not used by the EFI, it is provided as a means of configuration management.">
        <Data name="userdata" inMemoryType="unsigned8" array="8" comment="8 bytes of user writable and readable nonvolatile data"/>
        <Data name="comment" inMemoryType="string" array="512" comment="User comment string"/>
    </Packet>

    <Packet name="LockControl" title="Locking Control" ID="EFI_PKT_LOCKCONTROL" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="This packet is used to lock the configuration and set the unlock password. Each time the EFI starts the configuration is automaticaly locked and cannot be changed unless the [unlock](#EFI_PKT_UNLOCK) command is given. EFI locking has three levels: [`EFI_LCK_LOCKED`](#efiunlocklevels), [`EFI_LCK_PARTIAL_UNLOCKED`](#efiunlocklevels), and [`EFI_LCK_PASSWORD_UNLOCKED`](#efiunlocklevels).

For each set of configuration data (tables, governor, throttle, engine, pump, sensors, comms) this packet specifies the behavior of the protections when the password *has not yet been supplied*. There are three options: read/write, read only, and hidden. When configuration data are read/write the data can be requested when the efi is locked, and can be changed when the efi unlock level is [`EFI_LCK_PARTIAL_UNLOCKED`](#efiunlocklevels). When configuration data are read only the data can be requested when the efi is locked, but changing the data requires unlocking with the password. When configuration data are hidden the data cannot be requested or changed without unlocking using the password.

Upon receipt of this packet, if the EFI is currently unlocked, the configuration will be locked. The lock control configuration data are always protected at the read only level: therefore you can always request the lock control configuration but you cannot change it without doing a password unlock. Note that when sent from the EFI this packet will never include the password.">

        <Enum name="efiprotectionlevels" title="EFI protection levels" comment="Different levels of configuration data protecting">
            <Value name="EFI_PRT_READWRITE" comment="Configuration data is not password protected"/>
            <Value name="EFI_PRT_READONLY" comment="Configuration data can be requested but requires a password unlock to change"/>
            <Value name="EFI_PRT_HIDDEN" comment="Configuration can only be requested or changed with a password unlock"/>
        </Enum>

        <Data name="tablesProtection" enum="efiprotectionlevels" encodedType="bitfield2" comment="Protection level for all the table configuration data"/>
        <Data name="governorProtection" enum="efiprotectionlevels" encodedType="bitfield2" comment="Protection level for the RPM controller configuration data"/>
        <Data name="throttleProtection" enum="efiprotectionlevels" encodedType="bitfield2" comment="Protection level for the throttle configuration data"/>
        <Data name="engineProtection" enum="efiprotectionlevels" encodedType="bitfield2" comment="Protection level for the engine configuration data"/>
        <Data name="injectorProtection" enum="efiprotectionlevels" encodedType="bitfield2" comment="Protection level for the injector configuration data"/>
        <Data name="pumpProtection" enum="efiprotectionlevels" encodedType="bitfield2" comment="Protection level for the pump configuration data"/>
        <Data name="sensorsProtection" enum="efiprotectionlevels" encodedType="bitfield2" comment="Protection level for all sensor configuration data"/>
        <Data name="commsProtection" enum="efiprotectionlevels" encodedType="bitfield2" comment="Protection level for the communications configuration data"/>
        <Data name="maintenanceProtection" enum="efiprotectionlevels" encodedType="bitfield2" comment="Protection level for the maintenance and logbook data"/>
        <Data name="coolingProtection" enum="efiprotectionlevels" encodedType="bitfield2" comment="Protection level for the cooling configuration data"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield12" comment="Reserved bits in the packet"/>
        <Data name="reserved" inMemoryType="null" encodedType="unsigned32"/>
        <Data name="reserved" inMemoryType="null" encodedType="unsigned32"/>
        <Data name="password" inMemoryType="string" array="32" comment="Password for unlocking. This can be an empty string in which case no password is needed for unlocking. Requesting this packet will always return an empty string for the password."/>
    </Packet>

    <Packet name="ConfigHash" title="Valid Configuration" ID="EFI_PKT_CONFIGHASH" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="Send this packet to mark the current configuration as valid. Upon receipt of this packet, if the EFI is unlocked, a parameter hash of the configuration will be computed and stored. The EFI maintains a hash of the actual configuration which is compared with the stored value, generating a parameter mismatch error if the two values are different. In addition, if a hash is computed and stored, the EFI will be locked.

    When sending this packet to the EFI the values `storedParameterHash` and `actualParameterHash` are used as a command flag. Setting these to `0x00000000` and `0xFFFFFFFF` respectively will cause the EFI to disable the parameter mismatch check (and the EFI will not be locked). Any other value results in the computation and storage of the parameter hash, triggering the parameter mismatch check.

    When this packet comes from the EFI `storedParameterHash` will be `0x00000000` if the parameter mismatch check is disabled. If you change the EFI configuration (by sending a configuration packet) the EFI will recompute and resend the new configuration hash the next time it outputs slow telemetry. Alternatively you can request the configuration hash packet to get the updated `actualParameterHash`.">

        <Data name="storedParameterHash" inMemoryType="unsigned32" comment="Parameter hash that was stored the last time this packet was sent to the EFI, for packets coming from the EFI. If this value is zero the parameter mismatch check is not being performed."/>
        <Data name="actualParameterHash" inMemoryType="unsigned32" comment="The parameter hash that was computed from the stored configuration. This value is ignored for packets going to the EFI, it is available only on request."/>

    </Packet>

    <Packet name="PumpConfiguration" title="Fuel Pump Configuration" ID="EFI_PKT_PUMPCONFIGURATION" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="Configuration information for the fuel pump control. The fuel pump can be controlled using bang-bang feedback, or proportional-integral (PI) feedback. Bang-bang feedback simply toggles between minimum and maximum pump duty cycle based on comparing the fuel pressure error with the `fuelPressureBangBangThreshold`. In PI feedback the pump duty cycle is controlled using proportional and integral feedback of fuel pressure error combined with feedforward of fuel flow rate. The current fuel pump duty cycle is visible in the [slow telemetry](#EFI_PKT_TELEMETRYSLOW) packet.">
        <Data name="fuelPressureCmd" inMemoryType="float32" encodedType="unsigned16" scaler="50" comment="Desired fuel pressure in kilo-Pascals."/>
        <Data name="fuelPressureErrorThreshold" inMemoryType="float32" encodedType="unsigned16" scaler="250" comment="Fuel pressures in kilo-Pascals relative to the fuelPressureCmd which is used to define a fuel pressure error (too low or too high)"/>
        <Data name="minDutyCycle" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Minimum pump output duty cycle in percent."/>
        <Data name="maxDutyCycle" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Maximum pump output duty cycle in percent."/>
        <Data name="fuelPressureBangBangThreshold" inMemoryType="float32" encodedType="unsigned16" scaler="250" comment="Fuel pressure error threshold in kilo-Pascals for bang-bang pump control. If this is non-zero the fuel pump is controlled by bang-bang feedback."/>
        <Data name="proGain" inMemoryType="float32" encodedType="float16:10" comment="Feedback gain from fuel pressure error (in kilo-Pascals) to fuel pump duty cycle in percent. Must be positive."/>
        <Data name="intGain" inMemoryType="float32" encodedType="float16:10" comment="Feedback gain from fuel pressure error integral (in kilo-Pascals-seconds) to fuel pump duty cycle in percent. Must be positive."/>
        <Data name="forGain" inMemoryType="float32" encodedType="float16:10" comment="Feedforward gain from fuel flow rate in grams per minute to fuel pump duty cycle in percent. Must be positive."/>
        <Data name="rpmEnablesPump" inMemoryType="unsigned8" encodedType="bitfield1" comment="If set the fuel pump output will remain at 0% until a non-zero engine speed is detected. If clear the pump is allowed to run even if the engine is not running."/>
        <Data name="primeTime" inMemoryType="unsigned8" encodedType="bitfield7" comment="The amount of time, in seconds, the pump is allowed to run to prime the fuel system. If `rpmEnablesPump` is set, and if the RPM is zero, the pump will be allowed to run until 'primeTime' seconds have elapsed. If `rpmEnablesPump` is clear `primeTime` will do nothing. "/>
        <Data name="maxIfFailure" inMemoryType="unsigned8" encodedType="bitfield1" comment="If set the fuel pump output will be `maxDutyCycle` if the fuel pressure sensor is failed. Otherwise the pump output will be set according to the feedforward gain."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield7"/>
        <Data name="reserved" inMemoryType="null" array="3" encodedType="unsigned8"/>
        <Data name="positiveRateLimit" inMemoryType="float32" encodedType="unsigned8" scaler="0.02" comment="Rate limit on pump output, if the output is increasing, in units of % duty cycle per second. 0 will disable the positive rate limiter."/>
        <Data name="negativeRateLimit" inMemoryType="float32" encodedType="unsigned8" scaler="0.02" comment="Rate limit on pump output, if the output is decreasing, in units of % duty cycle per second. 0 will disable the negative rate limiter."/>
        <Data name="_outputRateLimit" inMemoryType="float32" encodedType="unsigned8" scaler="0.2" constant="0" comment="Deprecated rate limit on pump output in units of % duty cycle per second. 0 will disable the positive rate limiter. This field will only be used if it is positive and `positiveRateLimit` and `negativeRateLimit` are zero."/>
        <Code name="ratelimitfixup" decode="if((_pg_user->_outputRateLimit > 0) &amp;&amp; (_pg_user->positiveRateLimit == 0) &amp;&amp; (_pg_user->negativeRateLimit == 0)) _pg_user->positiveRateLimit = _pg_user->negativeRateLimit = _pg_user->_outputRateLimit;" comment="Apply logic to handle deprecated rate limit, which used to be symmetrical but is now superseded by the assymetrical rate limits with more range."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2" default="0"/>
        <Data name="pwmPeriod" inMemoryType="unsigned16" encodedType="bitfield14" min="20" default="1000" comment="Fuel pump PWM period in microseconds."/>
    </Packet>

    <Packet name="CommConfiguration" title="Communication Configuration" ID="EFI_PKT_COMMCONFIGURATION" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="Configuration information for communications, including Controller Area Network (CAN) setup, Universal Asynchronous Receiver Transmitter (UART) baud rate, and telemetry output options. If you select a baud rate (UART or CAN) which is too low to accommodate the telemetry output rates, the rates will be adjusted down until the expected bandwidth fits the available data rate. If you select the option `setToDefault` the UART baud rate will be set to 57600 bits per second, the fast telemetry rate will be 20Hz, and the slow telemetry rate will be 1Hz.

    The CAN configuration supports multiple options and protocols. The primary CAN protocol is the *native protocol*, which implements the packet-over-CAN schema to move packets as documented in this ICD. The native protocol includes input and output base identifiers, as well as a broadcast identifier. The input and output identifier must be unique on the CAN bus; but the broadcast identifier can be common with other EFIs on the bus. If you select the option `setToDefault` the native protocol will be configured to run at 1Mbit, with long identifiers, a type shift of 16 bits, an input identifier of `0x1E00xxxx`, and an output identifier of `0x1F00xxxx` (where `xxxx` are the lower 16 bits of the EFI serial number).

    In addition to the native communications protocol three other protocols are supported (Currawong, Piccolo, Performance Electronics). If you set `enableCurrawongECU` the EFI will emulate the communications protocol used by the [CE367 ECU](http://www.currawongeng.com/uav-engines/engine-control-unit/) from Currawong Engineering. The emulation of this interface includes telemetry, commands, and configuration packets, see the Currawong ECU ICD for details. The `enableCurrawongECU` bit is an option for both the UART and the CAN interface. On the UART interface the Currawong protocol runs at 57600 bits per second, and runs simultaneously with the native protocol (the EFI discriminates based on the packet format). The EFI will use the `alternativeProtocolAddress` for the address field in the Currawong serial packet. When using `enableCurrawongECU` with the CAN interface the EFI will generate CAN frames from `0x0800xxxx` through `0x0818xxxx` (where `xxxx` are the `alternativeProtocolAddress`), and will process CAN frames from `0x0900xxxx` through `0x0918xxxx` (where `xxxx` are `alternativeProtocolAddress`, or `0xFFFF`).

    The second alternative protocol is enabled with the option `enablePiccoloECU`. This protocol is only available on the CAN bus. You cannot simultaneously set `enablePiccoloECU` and `enableCurrawongECU` on the CAN bus, if you do the EFI will negate `enablePiccoloECU`. When using `enablePiccoloECU` the EFI will generate CAN frames from `0x0880xxxx` through `0x0884xxxx` (where `xxxx` are the `alternativeProtocolAddress`), and will process CAN frames from `0x0990xxxx` through `0x0991xxxx` (where `xxxx` are the `alternativeProtocolAddress`, or `0xFFFF`). Details of this protocool can be had in the Piccolo communications ICD. The [Piccolo autopilot](http://www.cloudcaptech.com/products/auto-pilots) CAN bus can work with either the Piccolo ECU or the Currawong ECU protocol. When using either protocol the CAN baud rate will be forced to 1Mbit, and the `outputBaseID` and `inputBaseID` must *not* be `0x08xxxxxx` or `0x09xxxx`, or the native output and input should be disabled.

    The third alternative protocol is enabled with the option `enablePE3ECU`. This is an output only protocol that emulates the CAN bus outputs of the Performance Electronics PE3 ECU. You can use the `enablePE3ECU` simultaneously with `enablePiccoloECU`, but not with `enableCurrawongECU` on the CAN bus. The PE3 protocol option does not force the CAN baud rate, and it does not follow the fast and slow telemetry rates; instead using the telemetry rates specified by the Performance Electronics protocol (20Hz, 10Hz, and 1Hz).

    The fourth alternative protocol is enabled with the option `enableGCU`. This is a CAN bus protocol which should be enabled if you want to decode telemetry from the Northwest or Millswood generator control unit. This protocol can be enabled with all other protocols and does not force the CAN baud rate. If this protocol is enabled, and if a GCU is sending telemetry on the CAN bus, IntelliJect will parse the telemetry data and forward it using the [TelemetryGCU packet](#EFI_PKT_TELEMETRYGCU).

    When using the Currawong, Piccolo, or PE3 alternative protocols the EFI will suppress the native protocol telemetry output on the interface. However if a native protocol packet is received on the interface the EFI will resume output of the native protocol telemetry.">

        <Enum name="CANBaudEnums" title="Baud rates for CAN" comment="Enumeration for baud rates on the CAN bus">
            <Value name="EFI_CAN_125K" comment="Baud rate of 125 thousand bits per second"/>
            <Value name="EFI_CAN_250K" comment="Baud rate of 250 thousand bits per second"/>
            <Value name="EFI_CAN_500K" comment="Baud rate of 500 thousand bits per second"/>
            <Value name="EFI_CAN_1M" comment="Baud rate of 1 million bits per second"/>
            <Value name="NUM_EFI_CANBAUDS"/>
        </Enum>
        <Data name="disableSDRecording" inMemoryType="bitfield1" comment="If set SD card recording will be disabled all the time, even if the engine is running."/>
        <Data name="fastTelemetrySDRate" inMemoryType="unsigned8" encodedType="bitfield7" comment="SD recording rate for fast telemetry."/>
        <Data name="fastTelemetryRate" inMemoryType="unsigned8" comment="Output rate for fast telemetry."/>
        <Data name="recordSDAlways" inMemoryType="bitfield1" comment="If set SD card recording will be enabled all the time, even if the engine is not running."/>
        <Data name="slowTelemetrySDRate" inMemoryType="unsigned8" encodedType="bitfield7" comment="SD recording rate for slow telemetry."/>
        <Data name="slowTelemetryRate" inMemoryType="unsigned8" comment="Output rate for slow telemetry."/>
        <Data name="useSummaryPackets" inMemoryType="bitfield1" comment="Set this bit to use summary packets for the telemetry on non-CAN interfaces."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield1"/>
        <Data name="setToDefault" inMemoryType="bitfield1" comment="Set this bit to configure all communications for default settings. If this bit is set all other fields are ignored when this packet is sent to the EFI."/>
        <Data name="enableCurrawongECU" inMemoryType="bitfield1" comment="Set this bit to emulate the Currawong ECU Serial interface. If this is set the regular telemetry output in native packet format is suppressed, and the `uartBaud` is forced to 57600."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="uartBaud" inMemoryType="unsigned32" encodedType="bitfield10" scaler="1/1200" comment="Baud rate for the UART in units of bits per second"/>
        <Structure name="CANconfig" comment="Configuration data for CAN communciations">
            <Data name="baud" enum="CANBaudEnums" encodedType="bitfield3" comment="Baud rate enumeration for the CAN bus"/>
            <Data name="typeShift" inMemoryType="unsigned8" encodedType="bitfield5" comment="The bit number of the least significant bit of the packet type ([efiPacketIds](#efiPacketIds)) in the native protocol CAN ID. This is the number of bits that the packet type will be left shifted to place it into the CAN ID."/>
            <Data name="longid" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set this bit to use 29-bit identifiers in the native protocol, else the CAN bus will use 11-bit identifiers."/>
            <Data name="reserved" inMemoryType="null" encodedType="bitfield1"/>
            <Data name="disableNativeInput" inMemoryType="bitfield1" comment="Set this bit to disable receipt of native protocol CAN communications (inputBaseId is don't care)."/>
            <Data name="inputBaseId" inMemoryType="unsigned32" encodedType="bitfield29" comment="The base value used to form the CAN identifier for input CAN frames. The CAN identifier is formed by left shifting the packet type according to typeShift and then ORing the result with this value."/>
            <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
            <Data name="disableNativeOutput" inMemoryType="bitfield1" comment="Set this bit to disable transmission of native protocol CAN communications."/>
            <Data name="outputBaseId" inMemoryType="unsigned32" encodedType="bitfield29" comment="The base value used to form the CAN identifier for outputput CAN frames. The CAN identifier is formed by left shifting the packet type according to typeShift and then ORing the result with this value."/>
            <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
            <Data name="disableNativeBroadcast" inMemoryType="bitfield1" comment="Set this bit to disable receipt of native protocol broadcast CAN communications (broadcastBaseId is don't care)."/>
            <Data name="broadcastBaseId" inMemoryType="unsigned32" encodedType="bitfield29" comment="The base value used to form the CAN identifier for broadcast input CAN frames. The CAN identifier is formed by left shifting the packet type according to typeShift and then ORing the result with this value. "/>
            <Data name="forcePacketOverCAN" inMemoryType="bitfield1" comment="Set this bit to force the system to use *only* the Packet-over-CAN schema, even for packets that have 8 or less bytes of data. This option is not recommended unless the EFI must be limited to a single identifier on the CAN bus. When this option is set the EFI will only output CAN frames that match exactly the `outputBaseId`, and will only accept CAN frames that exactly match the `inputBaseId` or the `broadcastBaseId`."/>
            <Data name="cmdAndTmOnly" inMemoryType="bitfield1" comment="Set this bit to limit the CAN bus to command and telemetry messages only. Attempts to request or change configuration using the CAN bus will be ignored. Packet-over-CAN will not be used since all remaining packets have 8 or less bytes of data (unless `forcePacketOverCAN` is set)."/>
            <Data name="reserved" inMemoryType="null" encodedType="bitfield3"/>
            <Data name="enableGCU" inMemoryType="bitfield1" comment="Set this bit to enable receive of the Generator Control Unit telemetry (Northwest or Millswood). This can be enabled simultaneously with the other alternative protocols."/>
            <Data name="enablePE3ECU" inMemoryType="bitfield1" comment="Set this bit to emulate the Performance Electronics PE3 ECU CAN interface. This can be set at the same time as `enablePiccoloECU`"/>
            <Data name="enableCurrawongECU" inMemoryType="bitfield1" comment="Set this bit to emulate the Currawong ECU CAN interface."/>
            <Data name="enablePiccoloECU" inMemoryType="bitfield1" comment="Set this bit to enable support for the Piccolo ECU CAN interface."/>
            <Data name="reserved" inMemoryType="null" encodedType="bitfield7"/>
            <Data name="reserved" inMemoryType="null" encodedType="unsigned8"/>
            <Data name="alternativeProtocolAddress" inMemoryType="unsigned16" comment="The 16-bit address to use with either the Currawong ECU or Piccolo ECU protocols. This address applies to Currawong ECU over serial as well as CAN"/>
        </Structure>
        
    </Packet>

    <Packet name="SensorConfiguration" title="Sensors Configuration" limitOnEncode="true" ID="EFI_PKT_SENSORCONFIGURATION" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="This packet gives configuration information for a single sensor. Send this packet with just the first byte to request a specific sensor configuration. Sensor configuration includes the sensor gain and offset, the minimum and maximum sensor readings beyond which the sensor is considered bad, and the default sensor value to use if the sensor is bad or disabled. If the sensor is configured as a kty84 or kty83 temperature sensor the gain should be nominally 1 and the offset nominally 0. If `enableAutocorrect` is set the sensor's calibration will be automatically adjusted to correct errors (if possible). The only automatically corrected sensor is the MAP sensor (pressure offset is corrected against Baro when engine is off).

    Sensor readings and error status are available in the [telemetry packets](#telemetrypacketsoutputbyintelliject).">
        <Enum name="efiSensorEnum" title="EFI Sensor List" lookupTitle="true" comment="Enumeration for sensors. Not all sensors exist in all variants of IntelliJect hardware.">
            <Value name="EFI_SENSOR_VOLT" title="Input Voltage" comment="Input voltage sensor, units of Volts"/>
            <Value name="EFI_SENSOR_MAT" title="MAT" comment="Manifold air temperature sensor, units of Celsius"/>
            <Value name="EFI_SENSOR_CHT1" title="CHT1" comment="First cylinder head temperature sensor, units of Celsius"/>
            <Value name="EFI_SENSOR_CHT2" title="CHT2" comment="Second cylinder head temperature sensor, units of Celsius"/>
            <Value name="EFI_SENSOR_MAP" title="MAP" comment="Manifold pressure sensor, units of kilo-Pascals"/>
            <Value name="EFI_SENSOR_FUELP" title="Fuel pressure" comment="Fuel pressure sensor, units of kilo-Pascals"/>
            <Value name="EFI_SENSOR_ANALOGTPS" title="Analog TPS" comment="Analog throttle sensor, units of percent"/>
            <Value name="EFI_SENSOR_CPUTEMP" title="CPU Temp" comment="Temperature of the CPU, units of Celsius"/>
            <Value name="EFI_SENSOR_SPARETEMP" title="Spare temp" comment="Spare temperature sensor, units of Celsius"/>
            <Value name="EFI_SENSOR_BARO" title="Digital Barometer" comment="Barometric pressure sensor, units of kilo-Pascals"/>
            <Value name="EFI_SENSOR_OAT" title="Outside Air Temp" comment="Temperature of the outside air, units of Celsius"/>
            <Value name="EFI_SENSOR_CURRENT" title="Current" comment="Input current sensor, units of Amps"/>
            <Value name="EFI_SENSOR_12VOLT" title="12 Volts" comment="12 Volt rail voltage sensor, units of Volts"/>
            <Value name="EFI_SENSOR_12CURRENT" title="12 Current" comment="12 Volt rail current sensor, units of Amps"/>
            <Value name="EFI_SENSOR_ANALOGBARO" title="Analog Barometer" comment="Analog barometric pressure sensor, units of kilo-Pascals"/>
            <Value name="EFI_SENSOR_MAXINDEX" value="EFI_SENSOR_ANALOGBARO" title="Maximum sensor index" hidden="true" ignoreLookup="true" comment="The maximum valid sensor index"/>
        </Enum>

        <Enum name="efiSensorEnumSize" title="EFI Sensor List size" hidden="true" comment="Size of the sensor list">
            <Value name="NUM_EFI_SENSORS" value="EFI_SENSOR_MAXINDEX+1" comment="The number of sensors in the EFI."/>
        </Enum>

        <Data name="enabled" inMemoryType="bitfield1" comment="Set to 1 to enable this sensor, disabled sensors will use the `failedvalue` or be ignored"/>
        <Data name="kty84" inMemoryType="bitfield1" comment="Set to 1 to indicate that this sensor is a KTY84 temperature sensor"/>
        <Data name="sealedGauge" inMemoryType="bitfield1" comment="Set to 1 to indicate this sensor is of the sealed gauge type. This only applies to the fuel pressure sensor. If clear the fuel pressure sensor is considered a normal gauge type."/>
        <Data name="sensor" enum="efiSensorEnum" encodedType="bitfield5" verifyMaxValue="EFI_SENSOR_MAXINDEX" comment="The enumeration identifying the sensor to which this packet applies."/>
        <Data name="filterlpf" inMemoryType="float32" encodedType="unsigned8" scaler="10" comment="Cutoff frequency for the low pass filter to apply to the sensor after conversion, 0 will disable the filter"/>
        <Data name="offset" inMemoryType="float32" encodedType="signed16" max="1" comment="Offset to be subtracted from the raw sensor reading, as a fraction of the sensor raw span"/>
        <Data name="gain" inMemoryType="float32" comment="Gain of the sensor in output units per full scale range. Sensor output = gain(reading - offset)."/>
        <Data name="failedvalue" inMemoryType="float32" encodedType="float16:10" comment="Sensor value to use if the sensor readings are out of range, or the sensor is disabled."/>
        <Data name="min" inMemoryType="float32" encodedType="float16:10" comment="Minimum sensor value, values below this are out of range"/>
        <Data name="max" inMemoryType="float32" encodedType="float16:10" comment="Maximum sensor value, values above this are out of range"/>
        <Data name="kty83" inMemoryType="bitfield1" comment="Set to 1 to indicate that this sensor is a KTY83 temperature sensor"/>
        <Data name="setToDefault" inMemoryType="bitfield1" comment="Set this bit to configure this sensor for default settings. All other settings in this packet will be ignored."/>
        <Data name="calibrate" inMemoryType="bitfield1" comment="Set this bit to perform a calibration for this sensor. This setting must be combined with `calibrateoffset` or `calibrategain` (but not both). This bit will never bet set when this packet comes from the EFI."/>
        <Data name="calibrateoffset" inMemoryType="bitfield1" comment="Set this bit to perform a zero calibration for this sensor. The offset of the sensor will be adjusted to make the sensor output match the calibration value. The `offset` field will be ignored in this case. This bit will never be set when this packet comes from the EFI."/>
        <Data name="calibrategain" inMemoryType="bitfield1" comment="Set this bit to perform a gain calibration for this sensor. The gain of the sensor will be adjusted to make the sensor output match the calibration value. The `gain` field will be ignored in this case. This bit will never be set when this packet comes from the EFI."/>
        <Data name="enableAutocorrect" inMemoryType="bitfield1" comment="Set this bit to enable this sensor to be automatically corrected."/>
        <Data name="platinum1000rtd" inMemoryType="bitfield1" comment="Set to 1 to indicate this sensor is a platinum RTD with a resistance of 1000 ohms at 0C. Offset should be set to 0, and the gain should be 1.0 if the TCR (Ohm/Ohm/C) of the sensor is 0.00385. Increase or decrease the gain to account for different TCR values."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield9" comment="Reserved space for future expansion"/>
        <Data name="calibrationvalue" inMemoryType="float32" dependsOn="calibrate" comment="The known sense value used with `calibrateoffset` or `calibrategain`."/>
        <Code name="verifyindices" decode="if(verifyefiSensorConfiguration_t(_pg_user) == 0) return 0;" comment="Call the function that verifies the sensor index."/>
    </Packet>

    <Packet name="ThrottleConfiguration" title="Throttle Configuration" ID="EFI_PKT_THROTTLECONFIGURATION" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment=
        "Configuration information specific to the throttle. There are two possible sources of throttle position sensing: The analog throttle sensor and the PWM input. If the EFI is configured to drive the throttle (`efiDrivesThrottle` is set) there are four possible sources of throttle command: The analog throttle, the PWM input, the user command, or the RPM controller. In addition, it is also possible to apply a throttle curve to convert the the commanded throttle to the actual throttle. Finally, if the EFI is configured to drive the throttle it is possible to *not* have a TPS sensor, in which case the throttle position is assumed to be equal the throttle output by the EFI.">

        <Data name="closedPWMoutput" inMemoryType="unsigned16" comment="PWM in microseconds for 0% throttle output (for `efiDrivesThrottle`)"/>
        <Data name="openPWMoutput" inMemoryType="unsigned16" comment="PWM in microseconds for 100% throttle output (for `efiDrivesThrottle`)"/>
        <Data name="inputfilterlpf" inMemoryType="float32" encodedType="unsigned8" scaler="10" comment="Cutoff frequency for the low pass filter to apply to the throttle input, 0 will disable the filter. This filter always applies to TPS as well as command inputs. This filter supercedes the filter on the analog throttle sensor configuration."/>
        <Data name="outputRateLimit" inMemoryType="float32" encodedType="unsigned8" scaler=".2" comment="Rate limit on throttle output, in units of % throttle per second. 0 will disable the rate limiter."/>
        <Data name="enableAnalogCmd" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable the use of the analog throttle input as a throttle command (only valid if `efiDrivesThrottle` is set)."/>
        <Data name="enablePWMCmd" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable the use of the PWM input as a throttle command (only valid if `efiDrivesThrottle` is set)."/>
        <Data name="efiDrivesThrottle" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if the EFI is driving the throttle (through PWM out or CAN)."/>
        <Data name="enableAnalogTPS" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable the use of the analog throttle input as a throttle position sensor. This cannot be set simultaneously with `enableAnalogCmd`."/>
        <Data name="enablePWMTPS" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable the use of the PWM throttle input as a throttle position sensor. This cannot be set simultaneously with `enablePWMCmd`."/>
        <Data name="_enableCECANServo" inMemoryType="unsigned8" encodedType="bitfield1" comment="Deprecated for api 7."/>
        <Data name="enableCECANTPS" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable the CAN servo position feedback as a throttle position sensor."/>
        <Data name="enableMAPTPS" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable the manifold pressure (plus the MAP estimate table) as a throttle position sensor."/>
        <Data name="curve" struct="Table1D" comment="The throttle curve relating throttle inputs to outputs. This can be disabled using the curve.enabled bit. The curve.indices are percent throttle input, and the curve.data are percent throttle output."/>
        <Data name="startThrottle" inMemoryType="float32" encodedType="unsigned8" scaler="2" default="15" comment="Throttle percentage used to start the engine in percent. If there is no valid throttle command, this is used to set the throttle position."/>
        <Data name="cecanAddress" inMemoryType="unsigned8" default="0" comment="Address, from 1 to 254, that identifies a Currawong Engineering CAN servo used for the throttle control if `efiDrivesThrottle` is set. Use 0 to disable the CAN servo output. The CAN bus must be configured for 1Mbit operation to work with the Currawong Engineering CAN servo."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield3"/>
        <Data name="tpsErrorThreshold" inMemoryType="float32" scaler="1" encodedType="bitfield5" default="0" comment="Throttle position sensor error threshold in percent, used to determine if the TPS sensor has an error (if `efiDrivesThrottle` is set). Zero to disable"/>
        <Data name="maxStartThrottle" inMemoryType="float32" encodedType="unsigned8" scaler="2" default="0" comment="Maximum throttle percentage that can be used to start the engine. If the engine is cranked with throttle above this value spark and injector outputs will be suspended. Use 0% to disable the start prevention feature."/>
        <Data name="closedPWMinput" inMemoryType="unsigned16" default="0" comment="PWM in microseconds for 0% throttle input (command or TPS), use zero to set `closedPWMinput` equal to `closedPWMoutput`"/>
        <Data name="openPWMinput" inMemoryType="unsigned16" default="0" comment="PWM in microseconds for 100% throttle input (command or TPS), use zero to set `closedPWMinput` equal to `closedPWMoutput`"/>
        <Data name="tpsFeedbackIntGain" inMemoryType="float32" encodedType="float16:10" default="0" comment="Integral feedback gain (/s) used to adjust throttle output to make the TPS value match the output command. The adjustment is only performed if this gain is non-zero, and if a TPS is enabled, and if `efiDrivesThrottle` is set."/>
                        
    </Packet>

    <Enum name="efiCrankWheelSyncStatus" comment="States of crank wheel synchronization">
        <Value name="noCrankWheelSync" comment="No syncrhonization information is available"/>
        <Value name="onegapCrankWheelSync" comment="One of the gaps has been discovered, no direction information"/>
        <Value name="twogapCrankWheelSync" comment="Both gaps have been discovered (or only one is configured)"/>
        <Value name="fullCrankWheelSync" comment="Big gap confirmed at the correct location"/>            
    </Enum>

    <Enum name="efiCrankDirection" comment="States of crank direction">
        <Value name="noCrankDirection" comment="Crank direction is unknown or cannot be known (single gap)"/>
        <Value name="normalCrankDirection" comment="Crank direction is normal rotation"/>
        <Value name="reverseCrankDirection" comment="Crank direction is reverse rotation"/>
    </Enum>

    <Packet name="CoolingConfiguration" title="Cooling configuration" ID="EFI_PKT_COOLINGCONFIGURATION" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="Configuration information for the cooling system.">
        <Data name="reserved" inMemoryType="null" encodedType="unsigned16"/>
        <Data name="chtTooCold" inMemoryType="float32" encodedType="unsigned8" scaler="1" comment="Head temperatures, in C, lower than this are an error (if the engine is running)."/>
        <Data name="chtTooHot" inMemoryType="float32" encodedType="unsigned8" scaler="1" comment="Head temperatures, in C, higher than this are an error."/>
        <Data name="chtDesired" inMemoryType="float32" encodedType="unsigned8" scaler="1" comment="Desired operating head temperature, in C."/>
        <Data name="derTime" inMemoryType="float32" encodedType="unsigned8" scaler="100" comment="Time in seconds used to compute the CHT rate. Longer times will have less noise but more lag."/>
        <Data name="trajGain" inMemoryType="float32" encodedType="float16:10" comment="Feedback trajectory gain from CHT error to CHT rate command. Must be positive. Use zero to disable the trajectory controller in favor of the classical controller."/>
        <Data name="forGain" inMemoryType="float32" encodedType="float16:10" comment="Feedforward gain from engine load (in percent) to cooling output in percent. Must be positive."/>
        <Data name="proGain" inMemoryType="float32" encodedType="float16:10" comment="Feedback gain from error (in C or C/s) to cooling output in percent. Must be positive."/>
        <Data name="intGain" inMemoryType="float32" encodedType="float16:10" comment="Feedback gain from error (in C or C/s) integral to cooling output in percent. Must be positive."/>
        <Data name="derGain" inMemoryType="float32" encodedType="float16:10" comment="Feedback gain from error derivative to the cooling output. Must be positive."/>
        <Data name="enableSplitCooling" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable split cooling in which CHT1 drives cooling output 1, CHT2 drives cooling output 2, and CHT3 drives cooling output 3."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield15"/>
        <Data name="closedPWM1" inMemoryType="unsigned16" comment="PWM in microseconds for 0% cooling or cowl flap position for cooling output 1"/>
        <Data name="openPWM1" inMemoryType="unsigned16" comment="PWM in microseconds for 100% cooling or cowl flap position for cooling output 1"/>
        <Data name="closedPWM2" inMemoryType="unsigned16" comment="PWM in microseconds for 0% cooling or cowl flap position for cooling output 2"/>
        <Data name="openPWM2" inMemoryType="unsigned16" comment="PWM in microseconds for 100% cooling or cowl flap position for cooling output 2"/>
        <Data name="cecanAddress1" inMemoryType="unsigned8" comment="Address, from 1 to 254, that identifies the first cowl flap servo on the CAN bus. The CAN bus must be configured for 1Mbit operation to work with the Currawong Engineering CAN servo. Use address 0 to disable the first CAN servo output."/>
        <Data name="cecanAddress2" inMemoryType="unsigned8" comment="Address, from 1 to 254, that identifies the second cowl flap servo on the CAN bus. The CAN bus must be configured for 1Mbit operation to work with the Currawong Engineering CAN servo. Use address 0 to disable the second CAN servo output."/>
    </Packet>

    <Structure name="CrankSense" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="Details of a crank sense for either once-per-rev or crank wheel sensors. Crank wheels provide higher resolution crank angle sensing than a typical once-per-rev hall sensor arrangement. In order to use the crank wheel you must specify the tooth count of the crank wheel, and the size of the sychronization gap. It is possible to have a directional crank wheel which uses two gaps of different size (a big gap and a small gap). Directional crank wheel sensors make it possible to prevent the engine from running in the wrong direction, or to enable it to run in either direction. Engine rotation is defined from the persective of looking at the output end of the engine (the end with the flywheel, propeller, transmission, etc.). From this perspective the rotation is normal if the rotation direction is clockwise">
        <Data name="enableWheel" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable crank wheel sensing. The `totalCount` and `bigGapCount` must be set correctly. If they are not then enable will be cleared."/>
        <Data name="activeHigh" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if the crank sense occurs on the rising edge, else crank sense is on the falling edge"/>
        <Data name="disableSensor" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to disable this sensor."/>
        <Data name="preferThisSensor" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to prefer this sensor over the other one."/>
        <Data name="senseDelay" inMemoryType="unsigned16" encodedType="bitfield12" comment="Time delay from crank sensor signal to detection of the crank sense signal, in microseconds. This time is subtracted from the clock time of the crank sense."/>
        <Data name="normalOffset" inMemoryType="float32" encodedType="unsigned16" max="360" comment="Angle of the active sense event in degrees of crank rotation after TDC. For directional crank wheel sensors this is the offset for clockwise (normal) rotation."/>
        <Data name="reverseOffset" inMemoryType="float32" encodedType="unsigned16" max="360" comment="Angle of the active sense event in degrees of crank rotation after TDC, for directional crank wheels in the reversed rotation direction."/>
        <Data name="totalCount" inMemoryType="unsigned8" comment="The number of teeth on the crank wheel plus the missing teeth. This is the full count, as though no synchronization teeth were removed."/>
        <Data name="bigGapCount" inMemoryType="unsigned8"  comment="The number of teeth missing in the big gap of the crank wheel. The end of the big gap is the crank angle synchronization point. There must always be a non-zero big gap count."/>
        <Data name="smallGapCount" inMemoryType="unsigned8" comment="The number of teeth missing in the small gap of the crank wheel. The small gap count can be zero, in which case there is no small gap; and therefore no ability to detect direction of rotation. The small gap count must be less than the big gap count for a functioning crank wheel."/>
        <Data name="normalIntraGapCount" inMemoryType="unsigned8" comment="The number of teeth between the big gap and the small gap for normal rotation. Zero if there is no small gap."/>
        <Data name="reverseIntraGapCount" inMemoryType="unsigned8" comment="The number of teeth between the big gap and the small gap for reverse rotation. Zero if there is no small gap. The intra gap count for reversed rotation should be the same as `totalCount` - `bigGapCount` - `smallGapCount` - `normalIntraGapCount`"/>
    </Structure>

    <Packet name="EngineConfiguration" title="Engine Configuration" ID="EFI_PKT_NEWENGINECONFIGURATION" comparefile="compare/eficompareutil" printfile="compare/efiprintutil"
            comment="Configuration information for the core engine. This packet is used to set a number of options about how to sense the crank shaft position, and control the spark.">

        <Data name="displacement" inMemoryType="float32" encodedType="unsigned16" scaler="10" comment="Engine displacement in cubic centimeters"/>
        <Data name="ignoreInputEnable" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to ignore the input line that enables/disabes the EFI. If set the input enable is always enabled. Note that the physical enable line must be high to trigger the CDI outputs. `ignoreInputEnable` is only useful for testing or if you are not using the CDI."/>
        <Data name="preventNormalRotation" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to prevent normal direction engine running. This only applies if the crank sense system can determine direction."/>
        <Data name="preventReverseRotation" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to prevent reverse direction engine running. This only applies if the crank sense system can determine direction."/>
        <Data name="_enableCrank2" inMemoryType="unsigned8" encodedType="bitfield1" comment="Deprecated setting for enabling crank sensor 2, this setting will only be obeyed if api8 is clear"/>
        <Data name="enableSpark3" inMemoryType="unsigned8" encodedType="bitfield1"/>
        <Data name="ignActiveHigh" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if the ignitions are triggered on a rising edge from the EFI, else ignition is triggered on the falling edge."/>
        <Data name="api8" inMemoryType="unsigned8" constant="1" encodedType="bitfield1" comment="This bit will be set for api8 or later packets."/>
        <Data name="api7" inMemoryType="null" constant="1" checkConstant="true" encodedType="bitfield1" comment="This bit will be set for api7 or later packets."/>
        <Data name="maxIgnDwellTime" inMemoryType="unsigned8" comment="Maximum ignition dwell time in milliseconds."/>
        <Data name="minIgnActiveTime" inMemoryType="unsigned16" comment="Minimum ignition active time in microseconds."/>
        <Data name="hardRevLimit" inMemoryType="float32" encodedType="unsigned16" scaler="1" comment="Maximum engine speed, above which spark and injection are turned off. Zero to disable the rev limiter."/>
        <Data name="softRevLimit" inMemoryType="float32" encodedType="unsigned16" scaler="1" comment="Engine speed above which spark and injection begin to turn off."/>
        <Data name="rpmfilterlpf" inMemoryType="float32" encodedType="unsigned8" scaler="10" comment="Cutoff frequency for the low pass filter to apply to the rpm, 0 will disable the filter"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield1"/>
        <Data name="mapErrorThreshold" inMemoryType="float32" scaler="2" encodedType="bitfield7" comment="Manifold pressure error threshold in kPa, used (along with the MAP estimate table) to determine if the manifold pressure has an error. Zero to disable."/>
        <Data name="crankSense1" struct="CrankSense" comment="Details of the crank sense configuration for crank sensor 1"/>
        <Data name="reserved" inMemoryType="null" encodedType="unsigned8"/>
        <Data name="crankSense2" struct="CrankSense" comment="Details of the crank sense configuration for crank sensor 2"/>
        <Data name="chtReference" inMemoryType="float32" encodedType="unsigned8" scaler="1" comment="Reference head temperature for fuel correction, in C."/>

        <Code name="api7handler" decode="if(!_pg_user->api8) _pg_user->crankSense2.disableSensor = !_pg_user->_enableCrank2;" comment="Correctly decode the enableCrank2 setting from api7"/>
    </Packet>

    <Packet name="InjectorConfiguration" title="Injectors Configuration" ID="EFI_PKT_INJECTORCONFIGURATION" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="Configuration information for the injector. The EFI supports three injector outputs. The injectors are operated so that the sum of all injectors is equal to the desired fuel output. The proportion of fuel that each injector outputs is controlled through the injector ratio tables. The EFI also supports injector skipping, in which short fuel injection pulses are accumulated into longer pulses for more precise control of the fuel delivery.

    Injectors can be configured to operate independently, which means that the fuel multiplier that comes from temperature is determined independently for each injector. There are four temperature sensors: a dedicated MAT sensor, two dedicated CHT sensors, and a spare sensor that can be configurable as a second MAT or third CHT. If the spare temp sensor is configured as manifold temp the fuel multiplier for injector1 is based on CHT1 and MAT, the fuel multiplier for injector2 is based on CHT2 and spare temp, and the fuel multiplier for injector3 is the average of injector1 and 2. If the spare temp sensor is configured as cylinder temp the fuel multiplier for injector1 is based on CHT1 and MAT, the fule multiplier for injector2 is based on CHT2 and MAT, and the fuel multiplier for injector3 is based on spare temp and MAT.">

        <Enum name="InjectorPhaseEdge" comment="Enumeration detailing the interpretation of injector phase">
            <Value name="injectorPhaseEnd" comment="The injector phasing describes the angle of the end of the injection"/>
            <Value name="injectorPhaseMid" comment="The injector phasing describes the angle of the middle of the injection"/>
            <Value name="injectorPhaseStart" comment="The injector phasing describes the angle of the start of the injection"/>
        </Enum>

        <Data name="enableInjector2" inMemoryType="bitfield1" comment="Set to enable the second injector."/>
        <Data name="enableInjectorIndependence" inMemoryType="bitfield1" comment="Set to allow injectors to independently compute fuel multipliers for temperature."/>
        <Data name="spareTempIsCHT" inMemoryType="bitfield1" comment="Set to assign the role of cylinder temperature 3 to the spare temp sensor."/>
        <Data name="spareTempIsMAT" inMemoryType="bitfield1" comment="Set to assign the role of manifold temperature 2 to the spare temp sensor."/>
        <Data name="enableInjector3" inMemoryType="bitfield1" comment="Set to enable the third injector."/>
        <Data name="injectorsAreRedundant" inMemoryType="bitfield1" comment="Set to allow injectors to operate redundantly, such that a fault on one injector causes the other injectors to pick up the fuel flow."/>
        <Data name="phaseEdge" enum="InjectorPhaseEdge" encodedType="bitfield2" comment="The injector phase edge specifies how to apply the injector phase table, and what injector angle is reported in telemetry"/>
        <Data name="fuelVolumePercentPerMAT" inMemoryType="float32" encodedType="unsigned8" scaler="200" comment="Percent fuel volume correction per degree C of MAT difference from 15C. Should be positive (volume goes up as temp goes up)."/>
        <Data name="multiplier" inMemoryType="float32" encodedType="float16:10" comment="Overall fuel multiplier to apply to the output of the fuel table."/>
        <Data name="nominalFuelPressure" inMemoryType="float32" encodedType="unsigned16" scaler="50" comment="Nominal injector pressure in kilo-Pascals."/>
        <Data name="nominalFlowrate1" inMemoryType="float32" encodedType="unsigned16" max="1200" comment="First injector full-on flow rate at the nominal pressure at 15C fuel temperature in grams per minute."/>
        <Data name="nominalFlowrate2" inMemoryType="float32" encodedType="unsigned16" max="1200" comment="Second injector full-on flow rate at the nominal pressure at 15C fuel temperature in grams per minute."/>
        <Data name="minOpeningTime1" inMemoryType="unsigned32" encodedType="unsigned16" comment="Minimum opening time in microseconds for the first injector. Injector pulses less than this will result in erroneous fueling, so the EFI will perform injector skipping to keep the injector opening times longer than this value."/>
        <Data name="minOpeningTime2" inMemoryType="unsigned32" encodedType="unsigned16" comment="Minimum opening time in microseconds for the second injector. Injector pulses less than this will result in erroneous fueling, so the EFI will perform injector skipping to keep the injector opening times longer than this value."/>
        <Data name="fuelUsedCorrector" inMemoryType="float32" encodedType="float16:10" comment="Multiplier to apply to the accumulated fuel injected to correct for any fuel consumption reporting error. This value does not affect the engine operation, just the fuel reporting."/>
        <Data name="nominalFlowrate3" inMemoryType="float32" encodedType="unsigned16" default="0" max="1200" comment="Third injector full-on flow rate at the nominal pressure at 15C fuel temperature in grams per minute."/>
        <Data name="minOpeningTime3" inMemoryType="unsigned32" encodedType="unsigned16" default="0" comment="Minimum opening time in microseconds for the third injector. Injector pulses less than this will result in erroneous fueling, so the EFI will perform injector skipping to keep the injector opening times longer than this value."/>
        <Data name="oilPrimingFreq" inMemoryType="float32" encodedType="bitfield5" scaler="2" default="10" comment="Frequency to run the oil injection pump for priming."/>
        <Data name="spareTempIsOilT" inMemoryType="bitfield1" default="0" comment="Set to assign the role of oil temperature to the spare temp sensor."/>
        <Data name="injector2IsOilInj" inMemoryType="bitfield1" default="0" comment="Set to enable the second injector output to be used for oil injection. This must not be set at the same time as enableInjector2."/>
        <Data name="injector3IsOilInj" inMemoryType="bitfield1" default="0" comment="Set to enable the third injector output to be used for oil injection. This must not be set at the same time as enableInjector3."/>
        <Data name="oilForStarting" inMemoryType="float32" encodedType="unsigned16" scaler="1.0" default="1000.0" comment="Oil to inject when the engine starts, in micrograms per cc of engine displacement"/>
        <Data name="oilUsedCorrector" inMemoryType="float32" encodedType="float16:10" default="1.0" scaler="100" comment="Multiplier to apply to the accumulated oil injected to correct for any oil consumption reporting error. This value does not affect the oil injection operation, just the reporting."/>
        <!--
        <Data name="reserved" inMemoryType="unsigned32" default="0"/>
        <Data name="autofuelEnabled" inMemoryType="unsigned8" default="0" encodedType="bitfield1" comment="Set to enable the autofuel algorithm"/>
        <Data name="autofuelAmplitude" inMemoryType="float32" default="0" encodedType="bitfield7" scaler="10" comment="Amplitude of the fuel oscillation in percent"/>
        <Data name="autofuelPeriod" inMemoryType="float32" default="0" encodedType="unsignd8" scaler="20" comment="Period of the autofuel oscillation in seconds"/>
        <Data name="autofuelMinThrottle" inMemoryType="float32" default="0" encodedType="unsigned8" scaler="2" comment="Minimum throttle, above which the autofuel algorithm can run"/>
        <Data name="autofuelMaxThrottle" inMemoryType="float32" default="0" encodedType="unsigned8" scaler="2" comment="Maximum throttle, below which the autofuel algorithm can run"/>
        <Data name="autofuelMaxThrottleDev" inMemoryType="float32" default="0" encodedType="unsigned8" scaler="20" comment="Maximum throttle deviation allowed."/>
        <Data name="autofuelCorrelationTarget" inMemoryType="float32" default="0" encodedType="float16:10" comment="The correlation target"/>
        <Data name="autofuelGain" inMemoryType="float32" default="0" encodedType="float16:10" comment="The correlation feedback gain"/>
        -->
    </Packet>

    <Packet name="RPMController" title="RPM Controller" ID="EFI_PKT_RPMCONTROLLER" comparefile="compare/eficompareutil" printfile="compare/efiprintutil"
            comment="Configuration information for the RPM controller. The RPM controller can only be used if the throttle
                    configuration has `efiDrivesThrottle` set. The RPM controller functions by moving the throttle. This is not
                    the same as the rev limiter, which functions by interrupting spark and injection.

                    The RPM controller can be commanded two different ways: either by directly commanding the controller with the
                    [RPM command](#EFI_PKT_RPMCOMMAND) packet; or the RPM controller can be driven by the throttle command in order
                    to achieve an RPM computed from the throttle command.

                    The RPM controller can run in two different feedback control modes. In the first mode (used if `trajGain` is zero) the feedback is based on RPM error. In the second mode the feedback is based on RPM rate error.">
        <Data name="minRPM" inMemoryType="float32" encodedType="unsigned16" scaler="1" comment="Minimum commandable engine speed. The RPM command will be limited to greater than or equal to this value."/>
        <Data name="maxRPM" inMemoryType="float32" encodedType="unsigned16" scaler="1" comment="Maximum commandable engine speed. The RPM command will be limited to less than or equal to this value. If the `maxRPM` is less than the `minRPM` the RPM controller settings will be set to defaults."/>
        <Data name="enableRPMfromThrottleCmd" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable RPM command from throttle command. If this is clear the RPM governor is only enabled when receiving a direct RPM command."/>
        <Data name="enableLowRPMLimiter" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to override the throttle command (when the governor is *not* running) to prevent RPM falling below the minRPM."/>
        <Data name="enableHighRPMLimiter" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to override the throttle command (when the governor is *not* running) to prevent RPM exceeding the maxRPM."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield1"/>
        <Data name="updateRate" inMemoryType="float32" encodedType="bitfield4" scaler="0.2" min="10" comment="Maximum frequency of the RPM control loop in Hertz. Slower reduces noise, faster improves responsiveness"/> 
        <Data name="throttleAtMinRPM" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="The throttle in percent which is expected to yield the minimum RPM. This term is used to compute the RPM command from the throttle command when running in throttle mode. It is also used to compute the feedforward throttle term when running in direct RPM mode, and the throttle output in direct RPM mode if the engine is not yet running."/>
        <Data name="rpmToThrottlePower" inMemoryType="float32" encodedType="float16:10" comment="Power relationship between rpm ratio (rpmcmd-minRPM)/(maxRPM-minRPM) and throttle. This term is used to compute the RPM command from the throttle command when running in throttle mode. It is also used to compute the feedforward throttle term when running in direct RPM mode, and the throttle output in direct RPM mode if the engine is not yet running."/>
        <Data name="rpmCmdfilterlpf" inMemoryType="float32" encodedType="unsigned8" scaler="10" comment="Low pass filter cutoff frequency applied to the rpm command. Use zero to disable the filter."/>
        <Data name="maxRateCmd" inMemoryType="float32" encodedType="float16:10" comment="Maximum RPM rate command in RPM/s, zero to disable the rate limiter. Must be positive."/>
        <Data name="trajGain" inMemoryType="float32" encodedType="float16:10" comment="Feedback trajectory gain from RPM error to RPM rate command. Must be positive. User zero to disable the trajectory controller in favor of the classical controller."/>
        <Data name="gainScaler" inMemoryType="float32" encodedType="float16:10" comment="Power applied to the inner loop gains. Positive numbers cause gains to increase as RPM increases. Negative numbers cause gains to decrease as RPM increases. 0 will cause gains to be constant with RPM."/>
        <Data name="forGain" inMemoryType="float32" encodedType="float16:10" comment="Feedforward gain from RPM command to the throttle. Must be positive."/>
        <Data name="proGain" inMemoryType="float32" encodedType="float16:10" comment="Feedback gain from error to the throttle. Must be positive."/>
        <Data name="intGain" inMemoryType="float32" encodedType="float16:10" comment="Feedback gain from error integral to the throttle. Must be positive."/>
        <Data name="derGain" inMemoryType="float32" encodedType="float16:10" comment="Feedback gain from error derivative to the throttle. Must be positive."/>
        <Data name="derivativeTime" inMemoryType="float32" encodedType="unsigned8" max="1.0" comment="Time in seconds used to compute the RPM rate. Longer times will have less noise but more lag."/>
        <Data name="outputfilterlpf" inMemoryType="float32" encodedType="unsigned8" scaler="10" comment="Low pass filter cutoff frequency applied to the rpm controller output. Use zero to disable the filter."/>
        <Data name="outputsoftband" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Percent throttle motion that falls into the 'softband', which increases the low pass filter strength. Use zero to disable the softband."/>

    </Packet>

    <Packet name="MaintenanceConfiguration" title="Maintenance schedule" ID="EFI_PKT_MAINTENANCECONFIGURATION" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="Set or request the maintenance schedule. The maintenance schedule is a list of maintenance service actions. You can see if any maintenance item is pending by checking the `maintenanceNeeded` bit of the [errors packet](#EFI_PKT_TELEMETRYERRORS). Details of the maintenance status are provided in the [maintenance status](#EFI_PKT_MAINTENANCESTATUS) packet. If you use this packet to change the number of maintenance items, the maintenance status will also be updated to keep the status items in sync with the schedule.">
        <Data name="reserved" inMemoryType="null" encodedType="bitfield3"/>
        <Data name="numItems" inMemoryType="unsigned8" encodedType="bitfield5" comment="The number of maintenance items"/>
        <Data name="hotTimeGain" inMemoryType="float32" encodedType="unsigned8" scaler="100" comment="Hot time multiplier gain in multiplier per degree overtemp."/>
        <Data name="highLoadThreshold" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Throttle position above which high load time begins accumulating"/>
        <Data name="reserved" inMemoryType="null" encodedType="unsigned8"/>
        <Structure name="MaintenanceItemConfig" array="maxMaintenanceItems" variableArray="numItems" comment="List of maintenance item">
            <Data name="reserved" inMemoryType="null" encodedType="bitfield5"/>
            <Data name="trigger" enum="MaintenanceTriggers" encodedType="bitfield3" comment="The trigger for this maintenance item"/>
            <Data name="interval" inMemoryType="unsigned32" encodedType="unsigned24" comment="The interval at which this maintenance should be done. For time triggers this is in seconds. Use zero to disable this maintenance item."/>
            <Data name="description" inMemoryType="string" array="64" comment="Brief description of the maintenance to be performed"/>
        </Structure>

    </Packet>

    <Packet name="HardwareInfo" title="Hardware Information" ID="EFI_PKT_HARDWAREINFO" comment="Hardware and manufacturing information. This data cannot be changed, only requested from the EFI.">
        <Data name="serial" inMemoryType="unsigned32" comment="32-bit serial number"/>
        <Data name="mattempcurrentdev" inMemoryType="float32" encodedType="signed8" scaler="1000000.0" comment="Deviation from the nominal current in Amps generated by the driver of the MAT sensor."/>
        <Data name="sparetempcurrentdev" inMemoryType="float32" encodedType="signed8" scaler="1000000.0" comment="Deviation from the nominal current in Amps generated by the driver of the Spare sensor."/>
        <Data name="cht1tempcurrentdev" inMemoryType="float32" encodedType="signed8" scaler="1000000.0" comment="Deviation from the nominal current in Amps generated by the driver of the CHT1 sensor."/>
        <Data name="cht2tempcurrentdev" inMemoryType="float32" encodedType="signed8" scaler="1000000.0" comment="Deviation from the nominal current in Amps generated by the driver of the CHT2 sensor."/>
        <Data name="reserved" inMemoryType="unsigned8" encodedType="bitfield4"/>
        <Data name="nomtempcurrent" inMemoryType="float32" scaler="1000000" encodedType="bitfield12" comment="Nominal current from the temp sensor drivers in Amps."/>
        <Code name="checknomtempcurrent" decode="if(_pg_user->nomtempcurrent &lt;= 0) _pg_user->nomtempcurrent = 0.001160f;" comment="Handle old packet which did not iclude this field"/>
        <Data name="revMajor" inMemoryType="unsigned8" comment="Major hardware revision number"/>
        <Data name="revMinor" inMemoryType="unsigned8" comment="Minor hardware revision number"/>
        <Data name="date" struct="Date" comment="The manufacture date of the hardware"/>
    </Packet>

    <Packet name="SoftwareInfo" title="Software Information" ID="EFI_PKT_SOFTWAREINFO" comment="Software version information. This data cannot be changed, only requested.">
        <Data name="swHash" inMemoryType="unsigned32" comment="Git hash number (short version) from the software repository for this build"/>
        <Data name="released" inMemoryType="bitfield1" comment="Set if software is released, otherwise this software is still being tested."/>
        <Data name="swMajorVersion" inMemoryType="bitfield7" comment="Major software revision number"/>
        <Data name="swMinorVersion" inMemoryType="unsigned8" comment="Minor software revision number"/>
        <Data name="reserved" inMemoryType="null" encodedType="unsigned16"/>
        <Data name="swBuild" inMemoryType="unsigned16" comment="Build number for this software. Larger build numbers are newer software"/>
        <Data name="date" struct="Date" comment="The release date of the software"/>
        <Data name="codecrc" inMemoryType="unsigned32" comment="The crc for the software load"/>
        <Data name="size" inMemoryType="unsigned32" encodedType="unsigned24" comment="The size of the program load in bytes."/>
        <Data name="description" inMemoryType="string" array="256" comment="Human readable description of the software release"/>
    </Packet>

    <Documentation comment="---"/>
    <Documentation name="Health and usage monitoring (HUMS)" paragraph="1" comment=
        "IntelliJect has a HUMS consisting of packets for [maintenance schedule](#EFI_PKT_MAINTENANCECONFIGURATION), [maintenance status](#EFI_PKT_MAINTENANCESTATUS), [engine wear packet](#EFI_PKT_ENGINEWEAR), and [digital logbook](#EFI_PKT_LOGENTRY). The goal of these packets is to replace the typical paper recording used for engine logging and maintenance, and to encourage the user to follow best practices regarding engine maintenance.

        The process starts with engine wear monitoring. Engine wear is continuously accumulated by IntelliJect and reported as part of the telemetry. It includes Hobbs time, number of engine revolutions, hot time, high load time, number of starts, and peak CHT that was recorded. See the [engine wear packet](#EFI_PKT_ENGINEWEAR) for more details.

        The [maintenance schedule](#EFI_PKT_MAINTENANCECONFIGURATION) is a configuration packet that specifies a list of service actions that should be taken in response to one of the variables in the engine wear. A common example would be changing the spark plugs after some period of engine time, or performing a hot section inspection if the CHT becomes too hot. IntelliJect compares the engine wear data to the maintenance schedule and status, and sets an [error bit](#EFI_PKT_TELEMETRYERRORS) if a maintenance item is due.

        The [maintenance status](#EFI_PKT_MAINTENANCESTATUS) records the status of a service item in the maintenance schedule. When service is performed the `domaintenance` command is used to inform IntelliJect; which then clears the `maintenanceNeeded` error bit, updates the status with the date and time of the service, name of the service technician, and relevant variable from the engine wear. Maintenance status is *not* part of the configuration, and `domaintenance` can be commanded without unlocking the configuration. Maintenance status also includes an engine serial number, which can be set if the IntelliJect is unlocked.

        The final HUMS packet is the [log entry](#EFI_PKT_LOGENTRY), which provides a simple list of log entries (one packet per entry). A log entry consists of a date and time, a user name, and a text description. Whenever maintenance is performed IntelliJect automatically adds a log entry with the details of the maintenance. A log entry can also be created manually and can be added without unlocking the configuration. It is possible to edit the log if the IntelliJect is unlocked."/>

        <Enum name="MaintenanceTriggers" lookupTitle="true" lookupComment="true" comment="Triggers for maintenance items">
            <Value name="maintenanceTriggerTime" title="Run time" comment="Maintenance is triggered by engine run time"/>
            <Value name="maintenanceTriggerRevs" title="Revolutions" comment="Maintenance is triggered by number of revolutions"/>
            <Value name="maintenanceTriggerHotTime" title="Hot time" comment="Maintenance is triggered by engine time above CHT limit"/>
            <Value name="maintenanceTriggerHighLoadTime" title="Load time" comment="Maintenance is triggered by engine time above the high load threshold"/>
            <Value name="maintenanceTriggerStarts" title="Starts" comment="Maintenance is triggered by number of engine starts"/>
            <Value name="maintenanceTriggerCHT" title="CHT" comment="Maintenance is triggered by cylinder head temperature"/>
            <Value name="numMaintenanceTriggers"/>
        </Enum>
            
        <Enum name="MaxMaintenanceItems" comment="Maximum number of maintenance items allowed in the schedule.">
            <Value name="maxMaintenanceItems" value="14" comment="Maximum number of maintenance items allowed in the schedule."/>
        </Enum>

        <Enum name="MaxNameCharacters" comment="Maximum number of characters in a user name.">
            <Value name="maxNameCharacters" value="20" comment="Maximum number of characters in a user name."/>
        </Enum>

    <Documentation comment="---"/>

    <Documentation name="IntelliJect tables" paragraph="1" comment=
        "Much of the configuration is done through two dimensional tables. Each table has row and column indices which can be selected from a list of [variables](#efiTableIndex). The most common choice of index variables are throttle and rpm.

        For each table the EFI performs a bilinear interpolated lookup based on the current operating condition to compute that tables output. The lookup is *not* extrapolated beyond the limits of the table indices. Each table can be enabled or disabled.

        Although tables support two dimensions it is acceptable to have only a single row, or a single column, or even just a single value. Tables with zero rows or zero columns are considered empty and are treated the same as tables which are disabled. If a table has only one row or one column then the index variable can be set to `null`. The maximum table size is 21 rows by 15 columns ([`EFI_TABLE_MAX_ROWS` x `EFI_TABLE_MAX_COLS`](#efiTableSize)).

        In addition to the value of each cell in the table, each cell also supports an 8-bit metadata value. IntelliJect does not use the metadata, it is provided simply so that per-cell configuration information can be included in the table (for example, a specific metadata value may indicate that a cell value has been dyno calibrated)."/>

    <Enum name="efiTableList" title="EFI Table List" lookupTitle="true" lookupComment="true" comment="List of tables used in the EFI.">
        <Value name="EFI_TABLE_FUEL"            title="Fuel (g/cc/rev)" comment="Fuel as micro-grams per revolution per cc of displacement."/>
        <Value name="EFI_TABLE_SPARK1ADV"       title="Spark Advance ()" comment="Spark1 advance in degrees."/>
        <Value name="EFI_TABLE_SPARK2DELAY"     title="Spark2 Delay ()" comment="Delay of spark2 after spark1 in degrees."/>
        <Value name="EFI_TABLE_CHARGETEMP"      title="Charge Temp coefficient" comment="Fraction of CHT (versus MAT) to use in the determination of the charge temperature."/>
        <Value name="EFI_TABLE_FM1"             title="Fuel multiplier 1" comment="First fuel multiplier."/>
        <Value name="EFI_TABLE_INJECTOR1PHASE"  title="Injector1 Phase ()" comment="First injector angle in degrees."/>
        <Value name="EFI_TABLE_INJECTOR1TRIM"   title="Injector1 Trim (s)" comment="First injector start time in microseconds."/>
        <Value name="EFI_TABLE_MINTHROTTLE"     title="Min Throttle (%)" comment="First minimum throttle in percent."/>
        <Value name="EFI_TABLE_MAXTHROTTLE"     title="Max Throttle (%)" comment="First maximum throttle in percent."/>
        <Value name="EFI_TABLE_SA1"             title="Spark adder 1 ()" comment="First spark adder in degrees."/>
        <Value name="EFI_TABLE_FM2"             title="Fuel multiplier 2" comment="Second fuel multiplier."/>
        <Value name="EFI_TABLE_FM3"             title="Fuel multiplier 3" comment="Third fuel multiplier."/>
        <Value name="EFI_TABLE_MAP"             title="MAP Estimate" comment="Ratio of manifold to baro pressure (for failed map sensor)."/>
        <Value name="EFI_TABLE_SHAFTPOWER"      title="Shaft Power (W)" comment="Shaft power in Watts on standard day."/>
        <Value name="EFI_TABLE_INJECTOR2RATIO"  title="Injector2 Ratio (%)" comment="Percentage of injector 2 versus injectors 1 and 3 in providing the total fuel flow."/>
        <Value name="EFI_TABLE_INJECTOR2PHASE"  title="Injector2 Phase ()" comment="Second injector angle in degrees."/>
        <Value name="EFI_TABLE_INJECTOR2TRIM"   title="Injector2 Trim (s)" comment="Second injector start time in microseconds."/>
        <Value name="EFI_TABLE_FM4"             title="Fuel multiplier 4" comment="Fourth fuel multiplier."/>
        <Value name="EFI_TABLE_IGNDWELL"        title="Ign Dwell (s)" comment="Microseconds of time the ignition output is inactive between sparks."/>
        <Value name="EFI_TABLE_SA2"             title="Spark adder 2 ()" comment="Second spark adder in degrees."/>
        <Value name="EFI_TABLE_FM5"             title="Fuel multiplier 5" comment="Fifth fuel multiplier."/>
        <Value name="EFI_TABLE_INJECTOR3RATIO"  title="Injector3 Ratio (%)" comment="Percentage of injector 3 versus injectors 1 and 2 in providing the total fuel flow."/>
        <Value name="EFI_TABLE_INJECTOR3PHASE"  title="Injector3 Phase ()" comment="Third injector angle in degrees."/>
        <Value name="EFI_TABLE_INJECTOR3TRIM"   title="Injector3 Trim (s)" comment="Third injector start time in microseconds."/>
        <Value name="EFI_TABLE_SPARK3DELAY"     title="Spark3 Delay ()" comment="Delay of spark3 after spark1 in degrees."/>
        <Value name="EFI_TABLE_MINTHROTTLE2"    title="Min Throttle2 (%)" comment="Second minimum throttle in percent."/>
        <Value name="EFI_TABLE_MAXTHROTTLE2"    title="Max Throttle2 (%)" comment="Second maximum throttle in percent."/>
        <Value name="EFI_TABLE_FM6"             title="Fuel multiplier 6" comment="Sixth fuel multiplier."/>
        <Value name="EFI_TABLE_FM7"             title="Fuel multiplier 7" comment="Seventh fuel multiplier."/>
        <Value name="EFI_TABLE_OILINJ_RATIO"    title="Fuel to oil ratio" comment="Desired ratio of fuel to oil."/>
        <Value name="EFI_TABLE_OILINJ_DUTY"     title="Oil pump duty cycle (%)" comment="Percentage duty cycle of the oil injection pump."/>
        <Value name="EFI_TABLE_OILINJ_OUTPUT"   title="Oil pump output (g/cycle)" comment="Output of the oil injection pump per pulse in micro-grams of oil."/>
        <Value name="EFI_TABLE_SA3"             title="Spark adder 3 ()" comment="Third spark adder in degrees."/>
        <Value name="EFI_TABLE_USER1"           title="User 1" comment="First user table."/>
        <Value name="EFI_TABLE_USER2"           title="User 2" comment="Second user table."/>
        <Value name="EFI_TABLE_USER3"           title="User 3" comment="Third user table."/>
        <Value name="EFI_TABLE_USER4"           title="User 4" comment="Fourth user table."/>
        <Value name="EFI_TABLE_MAXINDEX" value="EFI_TABLE_USER4" hidden="true" ignoreLookup="true" comment="Maximum table index."/>
	</Enum>

    <Enum name="efiTableListSize" title="EFI Table List size" hidden="true" comment="Size of the table list">
        <Value name="NUM_EFI_TABLES" value="EFI_TABLE_MAXINDEX+1" comment="The number of 2D tables in the EFI."/>
    </Enum>

    <Enum name="efiOldTableList" title="EFI Old Table List" hidden="true" comment="List of tables used in the 1.x version of the EFI">
        <Value name="EFI_OLDTABLE_FUEL"            title="Main Fuel" comment="Fuel as micro-grams per revolution per cc of displacement, indexed by [throttle/load, rpm]"/>
        <Value name="EFI_OLDTABLE_SPARK1ADV"       title="Spark Advance" comment="Spark1 advance in degrees, indexed by [throttle/load, rpm]"/>
        <Value name="EFI_OLDTABLE_SPARK2DELAY"     title="Spark2 Delay" comment="Delay of spark2 after spark1 in degrees, indexed by [throttle/load, rpm]"/>
        <Value name="EFI_OLDTABLE_CHARGETEMP"      title="Charge Temperature" comment="Fuel modifier for difference between head and inlet temperature: multiplier(k) = (k(CHTref - MAT) + MATa) / (k(CHT - MAT) + MATa), indexed by [throttle/load, rpm]"/>
        <Value name="EFI_OLDTABLE_HEADTEMP"        title="Head Temperature" comment="Fuel modifier for head temperature: multiplier(k) = (k + 1), indexed by [throttle/load, CHT]"/>
        <Value name="EFI_OLDTABLE_INJECTOR1PHASE"  title="Injector1 Phase" comment="First injector angle in degrees, indexed by [throttle/load, rpm]"/>
        <Value name="EFI_OLDTABLE_INJECTOR1TRIM"   title="Injector1 Trim" comment="First injector start time in microseconds, indexed by [pressure, volts]"/>
        <Value name="EFI_OLDTABLE_MINTHROTTLE"     title="Min Throttle" comment="Minimum throttle, indexed by [CHT cold, rpm]"/>
        <Value name="EFI_OLDTABLE_MAXTHROTTLE"     title="Max Throttle" comment="Maximum throttle, indexed by [CHT hot, rpm]"/>
        <Value name="EFI_OLDTABLE_SPARKRETARD"     title="Spark Retard" comment="Spark retard in degrees, indexed by [throttle/load, CHT hot]"/>
        <Value name="EFI_OLDTABLE_DOWNTRANSIENT"   title="Transient Down Fuel" comment="Fuel modifier for negative throttle transient in throttle percent per second: multiplier(k) = (k(dthrottle/dt) + 1), indexed by [throttle/load, rpm]"/>
        <Value name="EFI_OLDTABLE_2NDDENSITY_FUEL" title="2nd Order Density Fuel" comment="Fuel modifier for second order density ratio: multiplier(k) = (1 + k(1.225 - density)/1.225), indexed by [throttle/load, rpm]"/>
        <Value name="EFI_OLDTABLE_MAP"             title="MAP Estimate" comment="Ratio of manifold to baro pressure (for failed map sensor), indexed by [throttle, rpm]"/>
        <Value name="EFI_OLDTABLE_SHAFTPOWER"      title="Shaft Power" comment="Shaft power in Watts on standard day, indexed by [throttle/load, rpm]"/>
        <Value name="EFI_OLDTABLE_INJECTOR2RATIO"  title="Injector2 Ratio" comment="Percentage of injector 2 versus injectors 1 and 3 in providing the total fuel flow, indexed by [throttle/load, rpm]."/>
        <Value name="EFI_OLDTABLE_INJECTOR2PHASE"  title="Injector2 Phase" comment="Second injector angle in degrees, indexed by [throttle/load, rpm]"/>
        <Value name="EFI_OLDTABLE_INJECTOR2TRIM"   title="Injector2 Trim" comment="Second injector start time in microseconds, indexed by [pressure, volts]"/>
        <Value name="EFI_OLDTABLE_STARTFUEL"       title="Start Fuel" comment="Fuel multiplier used for starting, indexed by [CHT, numrevs]"/>
        <Value name="EFI_OLDTABLE_IGNDWELL"        title="Ign Dwell" comment="Microseconds of time the ignition output is inactive between sparks, indexed by [volts, rpm]"/>
        <Value name="EFI_OLDTABLE_DENSITY_SPARK"   title="Density Spark" comment="Spark advance adder for density ratio: adder(k) = k(1.225 - density)/1.225, indexed by [throttle/load, rpm]"/>
        <Value name="EFI_OLDTABLE_UPTRANSIENT"     title="Transient Up Fuel" comment="Fuel modifier for positive throttle transient in throttle percent per second: multiplier(k) = (k(dthrottle/dt) + 1), indexed by [throttle/load, rpm]"/>
        <Value name="EFI_OLDTABLE_INJECTOR3RATIO"  title="Injector3 Ratio" comment="Percentage of injector 3 versus injectors 1 and 2 in providing the total fuel flow, indexed by [throttle/load, rpm]."/>
        <Value name="EFI_OLDTABLE_INJECTOR3PHASE"  title="Injector3 Phase" comment="Third injector angle in degrees, indexed by [throttle/load, rpm]"/>
        <Value name="EFI_OLDTABLE_INJECTOR3TRIM"   title="Injector3 Trim" comment="Third injector start time in microseconds, indexed by [pressure, volts]"/>
        <Value name="EFI_OLDTABLE_SPARK3DELAY"     title="Spark3 Delay" comment="Delay of spark3 after spark1 in degrees, indexed by [throttle/load, rpm]"/>
        <Value name="EFI_OLDTABLE_MINTHROTTLE2"    title="Min Throttle2" comment="Second minimum throttle, indexed by [CHT cold, density ratio]"/>
        <Value name="EFI_OLDTABLE_MAXTHROTTLE2"    title="Max Throttle2" comment="Second maximum throttle, indexed by [CHT hot, density ratio]"/>
        <Value name="EFI_OLDTABLE_FUELMULT"        title="Main Fuel multiplier" comment="Fuel multiplier: multiplier(k) = (k + 1), indexed by [throttle/load, rpm]"/>
        <Value name="EFI_OLDTABLE_MAT"             title="Manifold Temperature" comment="Fuel modifier for manifold temperature: multiplier(k) = (k + 1), indexed by [throttle/load, MAT]"/>
        <Value name="EFI_OLDTABLE_OILINJ_RATIO"    title="Fuel to oil ratio" comment="Desired ratio of fuel to oil, indexed by [throttle/load, rpm]"/>
        <Value name="EFI_OLDTABLE_OILINJ_DUTY"     title="Oil injection duty cycle" comment="Duty cycle of the oil injection pump, indexed by [oil temperature, volts]"/>
        <Value name="EFI_OLDTABLE_OILINJ_OUTPUT"   title="Oil injection output per pulse" comment="Output of the oil injection pump per pulse, indexed by [oil temperature, duty cycle]"/>
        <Value name="EFI_OLDTABLE_MAXINDEX" value="EFI_OLDTABLE_OILINJ_OUTPUT" hidden="true" ignoreLookup="true" comment="Maximum old table index"/>
    </Enum>

    <Enum name="efiOldTableListSize" title="EFI Old Table List size" hidden="true" comment="Size of the old table list">
        <Value name="NUM_EFI_OLDTABLES" value="EFI_OLDTABLE_MAXINDEX+1" comment="The number of 2D old tables in the 1.x version of the EFI."/>
    </Enum>

    <Enum name="efiTableSize" title="EFI Table Size" comment="The maximum size of an EFI table">
        <Value name="EFI_TABLE_MAX_ROWS" value="21" comment="Maximum number of rows in an EFI table"/>
        <Value name="EFI_TABLE_MAX_COLS" value="15" comment="Maximum number of cols in an EFI table"/>
    </Enum>

    <Enum name="efiTableIndex" title="EFI Table Index Variable List" lookupTitle="true" lookupComment="true" comment="List of variables that can be used as row or column indexes in a table, or used as multipliers or dividers of table output">
        <Value name="EFI_TBLIDX_NULL" title="1.0" comment="The value of 1.0."/>
        <Value name="EFI_TBLIDX_THROTTLE" title="Throttle (%)" comment="Position of the throttle in percent."/>
        <Value name="EFI_TBLIDX_LOAD" title="Load (%)" comment="Percent ratio of manifold pressure to barometric pressure."/>
        <Value name="EFI_TBLIDX_RPM" title="RPM" comment="Engine speed in revolutions per minute."/>
        <Value name="EFI_TBLIDX_BARO_RATIO" title="Baro ratio" comment="Ratio of barometric air pressure to standard day pressure."/>
        <Value name="EFI_TBLIDX_MAP_RATIO" title="MAP ratio" comment="Ratio of manifold air pressure to standard day pressure."/>
        <Value name="EFI_TBLIDX_CHARGE_TEMP_RATIO" title="Charge temp ratio" comment="Ratio of absolute charge temperature to absolute charge temperature reference."/>
        <Value name="EFI_TBLIDX_MAT_RATIO" title="MAT ratio" comment="Ratio of manifold air absolute temperature to standard day absolute temperature."/>
        <Value name="EFI_TBLIDX_DENSITY_RATIO" title="Density ratio" comment="Ratio of air density to standard day density."/>
        <Value name="EFI_TBLIDX_ONEMINUS_DENSITY_RATIO" title="1 - Density ratio" comment="1.0 - the ratio of air density to standard day density."/>
        <Value name="EFI_TBLIDX_MAT" title="MAT (C)" comment="Average manifold air temperature."/>
        <Value name="EFI_TBLIDX_CHARGE_TEMP" title="Charge temp (C)" comment="Charge temperature."/>
        <Value name="EFI_TBLIDX_CHT" title="CHT (C)" comment="Average cylinder head temperature."/>
        <Value name="EFI_TBLIDX_CHTCOLD" title="CHT Cold (C)" comment="Coldest cylinder head temperature."/>
        <Value name="EFI_TBLIDX_CHTHOT" title="CHT Hot (C)" comment="Hottest cylinder head temperature."/>
        <Value name="EFI_TBLIDX_MAP" title="MAP (kPa)" comment="Manifold air pressure."/>
        <Value name="EFI_TBLIDX_BARO" title="Baro (kPa)" comment="Barometric air pressure."/>
        <Value name="EFI_TBLIDX_FUELP" title="Fuel pressure (kPa)" comment="Augmented fuel pressure (fuelp + baro - map)."/>
        <Value name="EFI_TBLIDX_FUELP_RAW" title="Raw fuel press. (kPa)" comment="Gauge fuel pressure."/>
        <Value name="EFI_TBLIDX_VOLTAGE" title="Voltage (V)" comment="Voltage of the injector rail."/>
        <Value name="EFI_TBLIDX_REVS" title="Revolutions" comment="Engine revolutions since start."/>
        <Value name="EFI_TBLIDX_TIME" title="Time (s)" comment="Elapsed time since engine start."/>
        <Value name="EFI_TBLIDX_THROTTLE_RATE" title="Throttle rate (%/s)" comment="Rate of change of the throttle position."/>
        <Value name="EFI_TBLIDX_POS_THROTTLE_RATE" title="Pos throt. rate (%/s)" comment="Rate of change of the throttle position, if the throttle rate is positive, else zero."/>
        <Value name="EFI_TBLIDX_NEG_THROTTLE_RATE" title="Neg throt. rate (%/s)" comment="Rate of change of the throttle position, if the throttle rate is negative, else zero."/>
        <Value name="EFI_TBLIDX_RPM_RATE" title="RPM rate (rpm/s)" comment="Rate of change of the engine speed."/>
        <Value name="EFI_TBLIDX_POS_RPM_RATE" title="Pos RPM rate (rpm/s)" comment="Rate of change of the engine speed, if the rpm rate is positive, else zero."/>
        <Value name="EFI_TBLIDX_NEG_RPM_RATE" title="Neg RPM rate (rpm/s)" comment="Rate of change of the engine speed, if the rpm rate is negative, else zero."/>
        <Value name="EFI_TBLIDX_OIL_TEMP" title="Oil temperature (C)" comment="Oil temperature."/>
        <Value name="EFI_TBLIDX_OIL_DUTY" title="Oil duty cycle (%)" comment="Duty cycle of the oil injection pump."/>
        <Value name="EFI_TBLIDX_OIL_ON_TIME" title="Oil on time (ms)" comment="The amount of time the oil injection pump is on per cycle."/>
        <Value name="EFI_TBLIDX_USER1" title="User 1" comment="Output of the user 1 table"/>
        <Value name="EFI_TBLIDX_USER2" title="User 2" comment="Output of the user 2 table"/>
        <Value name="EFI_TBLIDX_USER3" title="User 3" comment="Output of the user 3 table"/>
        <Value name="EFI_TBLIDX_USER4" title="User 4" comment="Output of the user 4 table"/>
        <Value name="EFI_TBLIDX_MAXINDEX" value="EFI_TBLIDX_USER4" hidden="true" ignoreLookup="true" comment="Maximum table variable index"/>
    </Enum>

    <Enum name="efiTableIndexSize" title="EFI Table Index Variable List size" hidden="true" comment="Size of the index list">
        <Value name="NUM_EFI_TBLIDXS" value="EFI_TBLIDX_MAXINDEX+1" comment="The number variables in the indice list."/>
    </Enum>

    <Documentation name="Fuel" paragraph="2" comment=
        "The fuel table (`EFI_TABLE_FUEL`) gives the total amount of fuel to be injected, in units of micro-grams of fuel per revolution, per cubic centimeter of engine displacement. The output of the fuel table is the amount of fuel to inject, if all fuel multipliers are 1.0. The default indices are [throttle, rpm]"/>

    <Documentation name="Spark 1 advance" paragraph="2" comment=
        "The spark 1 advance table (`EFI_TABLE_SPARK1ADV`) gives the amount of crank rotation, in degrees before top dead center, when the spark 1 output should be triggered, if all spark adders are 0. The default indices are [throttle, rpm]."/>

    <Documentation name="Spark 2 delay" paragraph="2" comment=
        "The spark 2 delay table (`EFI_TABLE_SPARK2DELAY`) gives the amount of crank rotation in degrees after spark 1 output to trigger the spark 2 output. It is common for the spark 2 delay table to be disabled, or to be all zeros, in which case spark 2 will fire at the same time as spark 1. The default indices are [throttle, rpm]."/>

    <Documentation name="Charge temperature" paragraph="2" comment=
        "The charge temperature table (`EFI_TABLE_CHARGETEMP`) gives the fraction of CHT versus MAT used to compute the charge temperature(k) = (k(CHT-MAT)+MAT); and the charge temperature reference(k) = (k(CHTref-15)+15). The charge temperature and charge temperature reference are used to compute the charge temperature ratio (ctratio) in one of two ways. If CHT reference is nonzero ctratio = (ChargeTemp + 273.15)/(ChargeTemp_ref + 273.15); if CHT reference is zero ctratio = (ChargeTemp + 273.15)/(288.15). The charge temperature models induction heating to determine the effective temperature of air trapped in the combustion chamber. The default indices are [throttle, rpm]."/>

    <Documentation name="First fuel multiplier" paragraph="2" comment=
        "The first fuel multiplier (`EFI_TABLE_FM1`) is a user configurable fuel multiplier. The default indices are [throttle, rpm]."/>

    <Documentation name="Injector 1 phase" paragraph="2" comment=
        "The injector 1 phase table (`EFI_TABLE_INJECTOR1PHASE`) gives the crank angle in degrees for the start, middle, or end of the injector 1 output. The injector 1 phase table has rows indexed by throttle or load and columns indexed by RPM."/>

    <Documentation name="Injector 1 trim" paragraph="2" comment=
        "The injector 1 trim table (`EFI_TABLE_INJECTOR1TRIM`) gives the amount of time in microseconds to add to the pulse sent to injector 1 to account for the difference in injector opening versus closing time. The injector trim should be positive if the injector opens slower than it closes and vice versa. The default indices are [fuel pressure, voltage]."/>

    <Documentation name="Minimum throttle" paragraph="2" comment=
        "The minimum throttle table (`EFI_TABLE_MINTHROTTLE`) gives the minimum throttle output in percent. This table is only useful if the EFI is driving the throttle. This table provides a way to adjust the idle speed of the engine. The default indices are [CHTcold, rpm]. "/>

    <Documentation name="Maximum throttle" paragraph="2" comment=
        "The maximum throttle table (`EFI_TABLE_MAXTHROTTLE`) gives the maximum throttle output in percent. This table is only useful if the EFI is driving the throttle. This table provides a way to limit the power output of the engine. The default indices are [CHThot, rpm]"/>
    
    <Documentation name="Spark retard" paragraph="2" comment=
        "The spark retard table (`EFI_TABLE_SPARKRETARD`) gives the reduction of the ignition advance in degrees. The spark retard table has rows indexed by throttle or load and columns indexed by the hottest head temperature. The retard table affects the advance of the all sparks equally. This table provides a way to manage engine knock. The default indices are [throttle, CHThot]"/>
    
    <Documentation name="Second fuel multiplier" paragraph="2" comment=
        "The second fuel multiplier (`EFI_TABLE_FM2`) is a user configurable fuel multiplier. The default indices are [throttle, rpm]"/>

    <Documentation name="Third fuel multiplier" paragraph="2" comment=
        "The third fuel multiplier (`EFI_TABLE_FM3`) is a user configurable fuel multiplier. The default indices are [throttle, rpm]"/>

    <Documentation name="Manifold pressure estimate" paragraph="2" comment=
        "The manifold pressure table (`EFI_TABLE_MAP`) gives a way to estimate the manifold pressure when the manifold pressure sensor is failed or disabled. The table gives the ratio of the manifold pressure to the barometric pressure. The default indices are [throttle, rpm]. Note: these are the only indices that make sense for this table."/>
    
    <Documentation name="Shaft power estimate" paragraph="2" comment=
        "The shaft power table (`EFI_TABLE_SHAFTPOWER`) provides an estimate of the shaft power, in Watts, on a standard dry day. The shaft power reported in the telemetry is computed from this table, using a mechanical efficiency estimate of 85% as well as the air density ratio, and the inverse of the charge temperature ratio. The default indices are [throttle, rpm]."/>
    
    <Documentation name="Injector 2 ratio" paragraph="2" comment=
        "The injector 2 ratio table (`EFI_TABLE_INJECTOR2RATIO`) gives the percent of the fuel that should be output by injector 2. If the table value is 0, all the fuel is output by injectors 1 and/or 3. If the table value is 100%, all the fuel is output by injector 2. The default indices are [throttle, rpm]."/>

    <Documentation name="Injector 2 phase" paragraph="2" comment=
        "The injector 2 phase table (`EFI_TABLE_INJECTOR2PHASE`) is the same as the injector 1 phase table, but the output is applied to injector 2."/>

    <Documentation name="Injector 2 trim" paragraph="2" comment=
        "The injector 2 trim table (`EFI_TABLE_INJECTOR2TRIM`) is the same as the injector 1 trim table, but the output is applied to injector 2."/>

    <Documentation name="Fourth fuel multiplier" paragraph="2" comment=
        "The fourth fuel multiplier (`EFI_TABLE_FM4`) is a user configurable fuel multiplier. The default indices are [throttle, rpm]."/>

    <Documentation name="Ignition dwell" paragraph="2" comment=
        "The ignition dwell table (`EFI_TABLE_IGNDWELL`) gives the amount of time the ignition output is in the inactive (non-spark) state between spark events. The dwell time is used to compute the amount of time the spark should be active, by subtracting the dwell time from the crank period. If the computed active time is less than the minimum active time from the engine configuration, the dwell will be reduced to honor the minimum active time. If the table is disabled the ignition active time will be the minimum active time. The default indices are [throttle, rpm]."/>

    <Documentation name="First spark adder" paragraph="2" comment=
        "The first spark adder table (`EFI_TABLE_SA1`) is a user configurable spark adder. The default indices are [throttle, rpm]."/>

    <Documentation name="Fifth fuel multiplier" paragraph="2" comment=
        "The fifth fuel multiplier (`EFI_TABLE_FM5`) is a user configurable fuel multiplier. The default indices are [throttle, rpm]."/>

    <Documentation name="Injector 3 ratio" paragraph="2" comment=
        "The injector 3 ratio table (`EFI_TABLE_INJECTOR3RATIO`) gives the percent of the fuel that should be output by injector 3. If the table value is 0, all the fuel is output by injectors 1 and/or 2. If the table value is 100%, all the fuel is output by injector 3. The default indices are [throttle, rpm]."/>

    <Documentation name="Injector 3 phase" paragraph="2" comment=
        "The injector 3 phase table (`EFI_TABLE_INJECTOR3PHASE`) is the same as the injector 1 phase table, but the output is applied to injector 3."/>

    <Documentation name="Injector 3 trim" paragraph="2" comment=
        "The injector 3 trim table (`EFI_TABLE_INJECTOR3TRIM`) is the same as the injector 1 trim table, but the output is applied to injector 3."/>

    <Documentation name="Spark 3 delay" paragraph="2" comment=
        "The spark 3 delay table (`EFI_TABLE_SPARK3DELAY`) gives the amount of crank rotation in degrees after spark 1 output to trigger the spark 3 output. The spark 3 delay table has rows indexed by throttle or load and columns indexed by RPM."/>

    <Documentation name="Second minimum throttle" paragraph="2" comment=
        "The second minimum throttle table (`EFI_TABLE_MINTHROTTLE2`) gives a second minimum throttle output in percent. This table is only useful if the EFI is driving the throttle. The actual minimum throttle is the larger of this table and the first minimum throttle table. The default indices are [CHTcold, density_ratio]."/>

    <Documentation name="Second maximum throttle" paragraph="2" comment=
        "The second maximum throttle table (`EFI_TABLE_MAXTHROTTLE2`) gives a second maximum throttle output in percent. This table is only useful if the EFI is driving the throttle. The actual maximum throttle is the smaller of this table and the first maximum throttle table. The default indices are [CHThot, density_ratio]"/>

    <Documentation name="Sixth fuel multiplier" paragraph="2" comment=
        "The sixth fuel multiplier (`EFI_TABLE_FM6`) is a user configurable fuel multiplier. The default indices are [throttle, rpm]."/>

    <Documentation name="Second spark adder" paragraph="2" comment=
        "The second spark adder table (`EFI_TABLE_SA2`) is a user configurable spark adder. The default indices are [throttle, rpm]."/>

    <Documentation name="Fuel to oil raio" paragraph="2" comment=
        "The fuel to oil ratio table (`EFI_TABLE_OILINJ_RATIO`) gives the desired ratio of fuel to oil. The default indices are [throttle, rpm]."/>

    <Documentation name="Oil injection duty cycle" paragraph="2" comment=
        "The oil injection duty cycle table (`EFI_TABLE_OILINJ_DUTY`) gives the desired duty cycle in percent of the oil injection pump. The default indices are [oil temp, voltage]. If no oil temperature sensor is configured the MAT is used instead. If this table is disabled the duty cycle is set to 50%."/>

    <Documentation name="Oil injection output per pulse" paragraph="2" comment=
        "The oil injection output per pulse table (`EFI_TABLE_OILINJ_OUTPUT`) gives the amount of oil injected, in micrograms, per pulse of the pump. The default indices are [oil temp, oil duty]. If this table is disabled the oil injection will not run."/>

    <Documentation name="Third spark adder" paragraph="2" comment=
        "The third spark adder table (`EFI_TABLE_SA3`) is a user configurable spark adder. The default indices are [throttle, rpm]."/>

    <Documentation name="User 1" paragraph="2" comment=
        "The first user table (`EFI_TABLE_USER1`) is a user configurable table whose output can be used as input to any other table. If this table is disabled its output is 0."/>

    <Documentation name="User 2" paragraph="2" comment=
        "The second user table (`EFI_TABLE_USER2`) is a user configurable table whose output can be used as input to any other table. If this table is disabled its output is 0."/>

    <Documentation name="User 3" paragraph="2" comment=
        "The third user table (`EFI_TABLE_USER3`) is a user configurable table whose output can be used as input to any other table. If this table is disabled its output is 0."/>

    <Documentation name="User 4" paragraph="2" comment=
        "The fourth user table (`EFI_TABLE_USER4`) is a user configurable table whose output can be used as input to any other table. If this table is disabled its output is 0."/>

    <Structure name="Table1D" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="One dimensional table">
        <Data name="enabled" inMemoryType="bitfield1" comment="Table enable. If clear then this table is not used"/>
        <Data name="num" inMemoryType="bitfield7" comment="Number of entries in this table"/>
        <Data name="indices" inMemoryType="float32" encodedType="float16:10" array="EFI_TABLE_MAX_COLS" variableArray="num" comment="List of independent variables"/>
        <Data name="data" inMemoryType="float32" encodedType="float16:10" array="EFI_TABLE_MAX_COLS" variableArray="num" comment="List of dependent variables"/>
    </Structure>

    <Packet name="Table2D_1x" title="2D Table Packet for 1.x versions" ID="EFI_PKT_TABLE" limitOnEncode="true" hidden="true" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="This packet is used to change or request a 2D table, for software version 1.x. It should not be used when communicating with 2.x IntelliJect. Send this packet with just the first byte to request a specific table.">
        <Data name="enabled" inMemoryType="bitfield1" comment="Table enable. If clear this table is not used"/>
        <Data name="loadfrommap" inMemoryType="bitfield1" comment="Set to use the percent ratio of manifold to baro pressure as the row axis index, otherwise use the throttle. This only applies to tables that use throttle/load for the row index."/>
        <Data name="index" enum="efiOldTableList" encodedType="bitfield6" verifyMaxValue="EFI_OLDTABLE_MAXINDEX" comment="Enumeration specifying to which old table this packet applies."/>
        <Data name="version2" inMemoryType="null" encodedType="bitfield1" constant="0" checkConstant="true" comment="This bit must be clear for a 1.x table."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield7"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield3"/>
        <Data name="numrows" inMemoryType="unsigned8" encodedType="bitfield5" verifyMaxValue="EFI_TABLE_MAX_ROWS" comment="Number of rows used in this table"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield3"/>
        <Data name="numcols" inMemoryType="unsigned8" encodedType="bitfield5" verifyMaxValue="EFI_TABLE_MAX_COLS" comment="Number of columns used in this table"/>
        <Data name="rowindices" inMemoryType="float32" encodedType="float16:10" array="EFI_TABLE_MAX_ROWS" variableArray="numrows" comment="The number of rows used in this table"/>
        <Data name="colindices" inMemoryType="float32" encodedType="float16:10" array="EFI_TABLE_MAX_COLS" variableArray="numcols" comment="The number of columns used in this table"/>
        <Data name="data" inMemoryType="float32" encodedType="float16:10" array="EFI_TABLE_MAX_ROWS" variableArray="numrows" array2d="EFI_TABLE_MAX_COLS" variable2dArray="numcols" comment="The table data organized as row major"/>
        <Data name="meta" inMemoryType="unsigned8" default="0" array="EFI_TABLE_MAX_ROWS" variableArray="numrows" array2d="EFI_TABLE_MAX_COLS" variable2dArray="numcols" comment="The table meta data organized as row major"/>
        <Code name="verifyindices" decode="if(verifyefiTable2D_1x_t(_pg_user) == 0) return 0;" comment="Call the function that verifies the table indices."/>
    </Packet>

    <Packet name="Table2D" title="2D Table Packet" ID="EFI_PKT_TABLE" limitOnEncode="true" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="This packet is used to change or request a 2D table. It should not be used when communicating with 1.x IntelliJect. Send this packet with just the first byte to request a specific table.">
        <Enum name="tableLookupOptions" hidden="true" comment="Enumerated options for how to do table lookups.">
            <Value name="no_tableLookupOptions" value="0" comment="Standard table lookup: no extrapolation, simple interpolation."/>
            <Value name="angle_tableLookup" value="1" comment="Table lookup uses angle rules for interpolation and output wrapping."/>
            <Value name="extrapolated_tableLookup" value="2" comment="Extrapolation allowed for table lookup."/>
            <Value name="extrapangle_tableLookup" value="3" comment="Table lookup uses angle rules and extrapolation."/>
        </Enum>

        <Data name="enabled" inMemoryType="bitfield1" comment="Table enable. If clear this table is not used"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield1"/>
        <Data name="index" enum="efiTableList" encodedType="bitfield6" verifyMaxValue="EFI_TABLE_MAXINDEX" comment="Enumeration specifying to which table this packet applies."/>
        <Data name="version2" inMemoryType="null" encodedType="bitfield1" constant="1" checkConstant="true" comment="This bit must be set for a 2.x table."/>
        <Data name="addone" inMemoryType="bitfield1" encodedType="bitfield1" comment="If set the result of the table interpolation is added to 1.0 after applying the multiplier and divider."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield6"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="rowindex" enum="efiTableIndex" encodedType="bitfield6" verifyMaxValue="EFI_TBLIDX_MAXINDEX" comment="Enumeration identifying what variable is used for the row index"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="colindex" enum="efiTableIndex" encodedType="bitfield6" verifyMaxValue="EFI_TBLIDX_MAXINDEX" comment="Enumeration identifying what variable is used for the column index"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="multiplierindex" enum="efiTableIndex" encodedType="bitfield6" verifyMaxValue="EFI_TBLIDX_MAXINDEX" comment="Enumeration identifying what variable is used to multiply the table output"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="dividerindex" enum="efiTableIndex" encodedType="bitfield6" verifyMaxValue="EFI_TBLIDX_MAXINDEX" comment="Enumeration identifying what variable is used to divide the table output"/>        
        <Data name="description" inMemoryType="string" array="28" comment="User definable name for the table."/>
        <Data name="reserved" inMemoryType="null" encodedType="unsigned32"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield3"/>
        <Data name="numrows" inMemoryType="unsigned8" encodedType="bitfield5" verifyMaxValue="EFI_TABLE_MAX_ROWS" comment="Number of rows used in this table"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield3"/>
        <Data name="numcols" inMemoryType="unsigned8" encodedType="bitfield5" verifyMaxValue="EFI_TABLE_MAX_COLS" comment="Number of columns used in this table"/>
        <Data name="rowindices" inMemoryType="float32" encodedType="float24:15" array="EFI_TABLE_MAX_ROWS" variableArray="numrows" comment="The number of rows used in this table"/>
        <Data name="colindices" inMemoryType="float32" encodedType="float24:15" array="EFI_TABLE_MAX_COLS" variableArray="numcols" comment="The number of columns used in this table"/>
        <Data name="data" inMemoryType="float32" encodedType="float24:15" array="EFI_TABLE_MAX_ROWS" variableArray="numrows" array2d="EFI_TABLE_MAX_COLS" variable2dArray="numcols" comment="The table data organized as row major"/>
        <Data name="meta" inMemoryType="unsigned8" array="EFI_TABLE_MAX_ROWS" variableArray="numrows" array2d="EFI_TABLE_MAX_COLS" variable2dArray="numcols" comment="The table meta data organized as row major"/>
        <Data name="disabledValue" inMemoryType="float32" encodedType="null" hidden="true" comment="The value to be output by the table lookup when this table is disabled. Set programatically, not by this packet."/>
        <Data name="lookupOptions" enum="tableLookupOptions" encodedType="null" hidden="true" comment="Options on how this table should do its lookups. Set programatically, not by this packet."/>
        <Code name="verifyindices" decode="if(verifyefiTable2D_t(_pg_user) == 0) return 0;" comment="Call the function that verifies the table indices."/>
        <Code name="settableoptions" decode="setTableOptions(_pg_user);" include="efitable.h" comment="Call the function that sets the `disabledValue` and `lookupOptions`."/>
    </Packet>

    <Packet name="TableValue" title="Table Cell Value" ID="EFI_PKT_TABLEVALUE" comment="Change a single table value and meta-value. Note that the table value packet incudes a 'do not store' flag. When calibrating an engine this packet is used frequently, and the do not store flag can be used to suppress the non-volatile storage update. IntelliJect will respond by sending the entire table back.">
        <Data name="donotstore" inMemoryType="bitfield1" comment="If set the table in memory will be updated, but not stored to non-volatile storage"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield1"/>
        <Data name="index" enum="efiTableList" encodedType="bitfield6" verifyMaxValue="EFI_TABLE_MAXINDEX" comment="Enumeration specifying to which table this packet applies."/>
        <Data name="version2" inMemoryType="bitfield1" constant="1" comment="This bit must be set for a 2.x table."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="row" inMemoryType="bitfield5" verifyMaxValue="EFI_TABLE_MAX_ROWS-1" comment="The row number, starting at zero."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield3"/>
        <Data name="col" inMemoryType="bitfield5" verifyMaxValue="EFI_TABLE_MAX_COLS-1" comment="The column number, starting at zero."/>
        <Data name="reserved" inMemoryType="null" encodedType="unsigned8"/>
        <Data name="value" inMemoryType="float32" encodedType="float16:10" comment="The value of this table at [row, col]"/>
        <Data name="meta" inMemoryType="unsigned8" comment="Meta data for this table cell"/>
        <Data name="value" inMemoryType="override" encodedType="float24:15" comment="The value of this table at [row, col] at higher resolution"/>
        <Code name="verifyindices" decode="if(verifyefiTableValue_t(_pg_user) == 0) return 0;" comment="Call the function that verifies the row and column index."/>
    </Packet>

    <Packet name="TableEnable" redefine="Table2D" title="Table Enable" ID="EFI_PKT_TABLE" comment="Change the table enable and the row or column index variables and the math index variables without changing the entire table. This packet is the same as the Table2D packet, but it excludes the row and column indices and the table data. IntelliJect will respond by sending the entire table back.">
        <Data name="enabled" inMemoryType="bitfield1" comment="Table enable. If clear this table is not used"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield1"/>
        <Data name="index" enum="efiTableList" encodedType="bitfield6" verifyMaxValue="EFI_TABLE_MAXINDEX" comment="Enumeration specifying to which table this packet applies."/>
        <Data name="version2" inMemoryType="null" encodedType="bitfield1" constant="1" checkConstant="true" comment="This bit must be set for a 2.x table."/>
        <Data name="addone" inMemoryType="bitfield1" encodedType="bitfield1" comment="If set the result of the table interpolation is added to 1.0 after applying the multiplier and divider."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield6"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="rowindex" enum="efiTableIndex" encodedType="bitfield6" verifyMaxValue="EFI_TBLIDX_MAXINDEX" comment="Enumeration identifying what variable is used for the row index"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="colindex" enum="efiTableIndex" encodedType="bitfield6" verifyMaxValue="EFI_TBLIDX_MAXINDEX" comment="Enumeration identifying what variable is used for the column index"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="multiplierindex" enum="efiTableIndex" encodedType="bitfield6" verifyMaxValue="EFI_TBLIDX_MAXINDEX" comment="Enumeration identifying what variable is used to multiply the table output"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="dividerindex" enum="efiTableIndex" encodedType="bitfield6" verifyMaxValue="EFI_TBLIDX_MAXINDEX" comment="Enumeration identifying what variable is used to divide the table output"/>
        <Code name="verifyindices" decode="if(verifyefiTable2D_t(_pg_user) == 0) return 0;" comment="Call the function that verifies the table indices."/>
        <Code name="settableoptions" decode="setTableOptions(_pg_user);" include="efitable.h" comment="Call the function that sets the `disabledValue` and `lookupOptions`."/>
    </Packet>
    
    <Documentation comment="---"/>
    <Documentation name="Telemetry Packets output by IntelliJect" paragraph="1"
        comment="These packets are sent automatically to report the system status. Telemetry packets (except summary packets) are 8 bytes so they can be transported in a single CAN frame. Telemetry packets fall into one of two categories: fast packets and slow packets. Fast packets are sent quickly because they contain rapidly changing information such as throttle position, engine speed, and rev count. Slow packets include status and sensor information.

        It is possible to send the telemetry in *summary packets*, see the [communications configuration](#EFI_PKT_COMMCONFIGURATION) for more details. When using summary packets the normally short telemetry packets are concatenated into longer packets (one summary packet for fast telemetry, and one for slow telemetry). This saves packet overhead bandwidth and is easier to process at the receiving end. Summary packets are not sent on the CAN bus, unless the communications configuration has the option `forcePacketOverCAN` set."/>

    <Packet name="TelemetryTime" title="Telemetry Time" ID="EFI_PKT_TELEMETRYTIME" useInOtherPackets="true" 
            comment="Time information for telemetry. The telemetry time packet is always output
                     immediately before the telemetry fast packet, and before the slow telemetry
                     packets. If fast and slow telemetry are output on the same epoch then only
                     a single time packet is output.">
        <Data name="time" inMemoryType="unsigned32" comment="Time in milliseconds since the system booted up."/>
        <Data name="fasttime" inMemoryType="bitfield1" comment="If set this time packet applies to fast telemetry data that immediately follows this packet."/>
        <Data name="slowtime" inMemoryType="bitfield1" comment="If set this time packet applies to slow telemetry data that follows this packet."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2" comment="Reserved bits for future expansion."/>
        <Data name="revcount" inMemoryType="unsigned32" encodedType="bitfield28" comment="Number of engine revolutions since the engine was last started."/>
    </Packet>

    <Enum name="efiThrottleSource" title="Throttle Source" comment="Source of the throttle information, for throttle command or throttle position sensor">
        <Value name="EFI_THROTTLE_START" comment="Throttle command comes form starting throttle setting; throttle position sense is unknown."/>
        <Value name="EFI_THROTTLE_CMD" comment="Throttle command comes from user command; throttle position sense is assumed to match output."/>
        <Value name="EFI_THROTTLE_PWMIN" comment="Throttle (command or sense) comes from PWM input"/>
        <Value name="EFI_THROTTLE_ANALOGIN" comment="Throttle (command or sense) comes from analog input"/>
        <Value name="EFI_THROTTLE_RPMDIRECT" comment="Throttle command comes from the RPM governor with a direct user command"/>
        <Value name="EFI_THROTTLE_MAP" comment="Throttle position sense comes from manifold pressure estimate"/>
        <Value name="EFI_THROTTLE_CAN" comment="Throttle position sense comes from CAN servo"/>
        <Value name="NUM_EFI_THROTTLES"/>
    </Enum>
        
    <Packet name="TelemetryFast" title="Fast Telemetry" ID="EFI_PKT_TELEMETRYFAST" useInOtherPackets="true" comment="Fast telemetry, output at the fast telemetry rate.">
        <Data name="rpm" inMemoryType="float32" encodedType="unsigned16" scaler="4" comment="Engine speed in revolutions per minute"/>
        <Data name="ioEnable" inMemoryType="bitfield1" comment="Global enable based on physical input"/>
        <Data name="userEnable" inMemoryType="bitfield1" comment="User global enable."/>
        <Data name="spark1Enable" inMemoryType="bitfield1" comment="User enable for spark1."/>
        <Data name="spark2Enable" inMemoryType="bitfield1" comment="User enable for spark2."/>
        <Data name="spark3Enable" inMemoryType="bitfield1" comment="User enable for spark3."/>
        <Data name="throttleCmdSrc" enum="efiThrottleSource" encodedType="bitfield3" comment="Source of the throttle command information. If the EFI is driving the throttle this is the command source. If the EFI is not driving the throttle this is the source of throttle position data."/>
        <Data name="throttleCmd" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Throttle command (0 to 100%) going in."/>
        <Data name="throttlePos" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Throttle position (0 to 100%) this may be different from the throttleCmd if a curve is applied, or if the governor is interpreting the throttle command."/>
        <Data name="injector3Duty" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="The third injector duty cycle in percent"/>
        <Data name="injector1Duty" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="The first injector duty cycle in percent"/>
        <Data name="injector2Duty" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="The second injector duty cycle in percent"/>
    </Packet>

    <Packet name="TelemetryFastSummary" title="Fast Telemetry Summary Packet" ID="EFI_PKT_TELEMETRYFASTSUM" parameterInterface="true" comment="Summary packet that contains all the fast telemetry in a single packet.">
        <Data name="time" struct="TelemetryTime" comment="Time information for the fast telemetry"/>
        <Data name="fast" struct="TelemetryFast" comment="Fast EFI telemetry"/>
    </Packet>

    <Packet name="TelemetrySensors" title="Telemetry Sensors" ID="EFI_PKT_TELEMETRYSENSORS" useInOtherPackets="true" comment="First set of sensor telemetry, output at slow telemetry rate.">
        <Data name="_cht" inMemoryType="float32" encodedType="unsigned8" scaler="1" comment="Combined cylinder head temperature in C, used for table lookups. This is a deprecated field, prefer the field in Telemetry Sensors 4."/>
        <Data name="throttlePosSrc" enum="efiThrottleSource" encodedType="bitfield3" comment="Source of throttle position information used for table lookups"/>
        <Data name="spareTempIsCHT3" inMemoryType="bitfield1" comment="This bit is set if spare temperature is configured to act as the third CHT"/>
        <Data name="spareTempIsMAT2" inMemoryType="bitfield1" comment="This bit is set if spare temperature is configured to act as the second MAT"/>
        <Data name="spareTempIsOilT" inMemoryType="bitfield1" comment="This bit is set if spare temperature is configured to act as oil temperature"/>
        <Data name="sparetemp" inMemoryType="float32" encodedType="bitfield10" scaler="2" min="-100" comment="Spare temperature in C"/>
        <Data name="mat" inMemoryType="float32" encodedType="signed8" scaler="1" comment="Manifold air temperature in C"/>
        <Data name="map" inMemoryType="float32" encodedType="bitfield12" scaler="31.25" comment="Manifold air pressure in kiloPascals."/>
        <Data name="baro" inMemoryType="float32" encodedType="bitfield12" scaler="31.25" comment="Baro air pressure in kiloPascals."/>
        <Data name="oat" inMemoryType="float32" encodedType="signed8" scaler="1" comment="Outside air temperature (as measured by the digital barometer) in C."/>
    </Packet>

    <Packet name="TelemetrySensorsapi7" title="Telemetry Sensors (api=7, deprecated)" hidden="true" encode="false" ID="EFI_PKT_TELEMETRYSENSORS" useInOtherPackets="true" comment="First set of sensor telemetry, output at slow telemetry rate.">
        <Data name="_cht" inMemoryType="float32" encodedType="unsigned8" scaler="1" comment="Combined cylinder head temperature in C, used for table lookups. This is a deprecated field, prefer the field in Telemetry Sensors 4."/>
        <Data name="_cht1" inMemoryType="float32" encodedType="unsigned8" scaler="1" comment="First cylinder head temperature in C. This is a deprecated field, prefer the field in Telemetry Sensors 4."/>
        <Data name="sparetemp" inMemoryType="float32" encodedType="signed8" scaler="1" comment="Spare temperature in C"/>
        <Data name="mat" inMemoryType="float32" encodedType="signed8" scaler="1" comment="Manifold air temperature in C"/>
        <Data name="map" inMemoryType="float32" encodedType="bitfield12" scaler="31.25" comment="Manifold air pressure in kiloPascals."/>
        <Data name="baro" inMemoryType="float32" encodedType="bitfield12" scaler="31.25" comment="Baro air pressure in kiloPascals."/>
        <Data name="oat" inMemoryType="float32" encodedType="signed8" scaler="1" comment="Outside air temperature (as measured by the digital barometer) in C."/>
    </Packet>

    <Packet name="TelemetrySensors2" title="Telemetry Sensors 2" ID="EFI_PKT_TELEMETRYSENSORS2" useInOtherPackets="true" comment="Second set of sensor telemetry, output at slow telemetry rate. The crank sense active signals will be set if the crank sense input is in the active state when this message is generated. This is useful only for measuring the crank sense timing, but not for determining anything when the engine is running.">
        <Data name="measuredCrank2Angle" inMemoryType="float32" encodedType="bitfield12" scaler="10" comment="Measured synchronization angle of crank sense 2, as determined by crank sense 1."/>
        <Data name="devCrank2Angle" inMemoryType="float32" encodedType="bitfield4" scaler="2" comment="Standard deviation of the measured synchronization angle of crank sense 2, as determined by crank sense 1."/>
        <Data name="_density" inMemoryType="float32" encodedType="bitfield12" max="3.0" comment="Estimated air density in kilogram per cubic meter, deprecated in api 10."/>
        <Data name="expectSensors4" inMemoryType="bitfield1" constant="1" comment="If this bit is set the receiver can expect that sensors4 data will be sent from the EFI, otherwise the EFI is older and the deprecated fields in TelemetrySensors and TelemetrySensors2 should be used."/>
        <Data name="api8" inMemoryType="bitfield1" constant="1" checkConstant="true" comment="Set if this packet comes from API 8 or later"/>
        <Data name="crankSense1Active" inMemoryType="bitfield1" comment="Set if the first crank sense signal is in the active state."/>
        <Data name="crankSense2Active" inMemoryType="bitfield1" comment="Set if the second crank sense signal is in the active state"/>
        <Data name="cooling2" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Second cooling output in percent"/>
        <Data name="tpsError" inMemoryType="float32" encodedType="signed8" scaler="10" comment="Error in percent between throttle output and TPS measurement"/>
        <Data name="analogTPS" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Analog throttle position sensor in percent"/>
        <Data name="pwmTPS" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="PWM throttle position sensor in percent"/>
    </Packet>

    <Packet name="TelemetrySensors2api7" title="Telemetry Sensors 2 (api=7, deprecated)" hidden="true" encode="false" ID="EFI_PKT_TELEMETRYSENSORS2" useInOtherPackets="true" comment="Second set of sensor telemetry, output at slow telemetry rate. The crank sense active signals will be set if the crank sense input is in the active state when this message is generated. This is useful only for measuring the crank sense timing, but not for determining anything when the engine is running.">
        <Data name="_fuelp" inMemoryType="float32" encodedType="unsigned16" scaler="50" comment="Fuel pressure in kiloPascals. This is a deprecated field, prefer the field in Telemetry Sensors 4."/>
        <Data name="density" inMemoryType="float32" encodedType="bitfield12" max="3.0" comment="Estimated air density in kilogram per cubic meter."/>
        <Data name="expectSensors4" inMemoryType="bitfield1" comment="If this bit is set the receiver can expect that sensors4 data will be sent from the EFI, otherwise the EFI is older and the deprecated fields in TelemetrySensors and TelemetrySensors2 should be used."/>
        <Data name="api8" inMemoryType="bitfield1" constant="0" checkConstant="true" comment="Clear if this packet comes from before API 8"/>
        <Data name="crankSense1Active" inMemoryType="bitfield1" comment="Set if the first crank sense signal is in the active state."/>
        <Data name="crankSense2Active" inMemoryType="bitfield1" comment="Set if the second crank sense signal is in the active state"/>
        <Data name="cooling2" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Second cooling output in percent"/>
        <Data name="tpsError" inMemoryType="float32" encodedType="signed8" scaler="10" comment="Error in percent between throttle output and TPS measurement"/>
        <Data name="analogTPS" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Analog throttle position sensor in percent"/>
        <Data name="pwmTPS" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="PWM throttle position sensor in percent"/>
    </Packet>

    <Packet name="TelemetrySensors3api0" title="Telemetry Sensors 3 (api=0, deprecated)" hidden="true" encode="false" ID="EFI_PKT_TELEMETRYSENSORS3" useInOtherPackets="true" comment="Third set of sensor telemetry, output at slow telemetry rate.">
        <Data name="inputVolts" inMemoryType="float32" encodedType="bitfield9" scaler="10" comment="Input voltage in Volts."/>
        <Data name="inputCurrent" inMemoryType="float32" encodedType="bitfield7" scaler="40" comment="Input current in Amps."/>
        <Data name="volts12" inMemoryType="float32" encodedType="unsigned8" min="7" scaler="25" comment="12V rail voltage in Volts."/>
        <Data name="current12" inMemoryType="float32" encodedType="unsigned8" scaler="40" comment="12V rail current in Amps."/>
    </Packet>

    <Packet name="TelemetrySensors3" title="Telemetry Sensors 3" ID="EFI_PKT_TELEMETRYSENSORS3" useInOtherPackets="true" comment="Third set of sensor telemetry, output at slow telemetry rate.">
        <Data name="inputVolts" inMemoryType="float32" encodedType="bitfield9" scaler="10" comment="Input voltage in Volts."/>
        <Data name="inputCurrent" inMemoryType="float32" encodedType="bitfield7" scaler="40" comment="Input current in Amps."/>
        <Data name="volts12" inMemoryType="float32" encodedType="unsigned8" min="7" scaler="25" comment="12V rail voltage in Volts."/>
        <Data name="current12" inMemoryType="float32" encodedType="unsigned8" scaler="40" comment="12V rail current in Amps."/>
        <Data name="baroDigital" inMemoryType="float32" encodedType="bitfield12" scaler="31.25" comment="Baro air pressure in kiloPascals from the digital barometer."/>
        <Data name="baroAnalog" inMemoryType="float32" encodedType="bitfield12" scaler="31.25" comment="Baro air pressure in kiloPascals from the analog barometer."/>
        <Data name="reserved" inMemoryType="null" encodedType="unsigned8"/>
    </Packet>

    <Packet name="TelemetrySensors4" title="Telemetry Sensors 4" ID="EFI_PKT_TELEMETRYSENSORS4" useInOtherPackets="true" comment="Fourth set of sensor telemetry, output at slow telemetry rate.">
        <Data name="cht" inMemoryType="float32" encodedType="bitfield10" scaler="2" min="-100" comment="Average cylinder head temperature in C."/>
        <Data name="cht1" inMemoryType="float32" encodedType="bitfield10" scaler="2" min="-100" comment="First cylinder head temperature in C."/>
        <Data name="cht2" inMemoryType="float32" encodedType="bitfield10" scaler="2" min="-100" comment="Second cylinder head temperature in C."/>
        <Data name="crankdirection" enum="efiCrankDirection" encodedType="bitfield2" comment="The direction of rotation measured by the crank wheel(s) or by the once-per-rev sensors."/>
        <Data name="chargeTempCoef" inMemoryType="float32" encodedType="unsigned8" scaler="200" comment="Charge temperature coefficient from 0 to 1 that determines how much CHT is used in the computation of charge temperature."/>
        <Data name="_fmHeadTemp2" inMemoryType="float32" constant="1" encodedType="unsigned8" scaler="100" comment="Deprecated in API 10, do not use."/>
        <Data name="fuelp" inMemoryType="float32" encodedType="float16:10" comment="Fuel pressure in kiloPascals."/>
    </Packet>

    <Packet name="TelemetryFuel" title="Telemetry Fuel" ID="EFI_PKT_TELEMETRYFUEL" useInOtherPackets="true" comment="Fueling telemetry, output at the slow telemetry rate">
        <Data name="fuelFlowRate" inMemoryType="float32" encodedType="float16:10" comment="Fuel flow rate in grams per minute."/>
        <Data name="fuelConsumption" inMemoryType="float32" encodedType="float16:10" comment="Fuel consumption in grams since the system turned on."/>
        <Data name="fmInjector1" inMemoryType="float32" encodedType="unsigned8" scaler="50" comment="Total fuel multiplier for injector 1, including the main fuel multiplier."/>
        <Data name="fmInjector2" inMemoryType="float32" encodedType="unsigned8" scaler="50" comment="Total fuel multiplier for injector 2, including the main fuel multiplier."/>
        <Data name="fmInjector3" inMemoryType="float32" encodedType="unsigned8" scaler="50" comment="Total fuel multiplier for injector 3, including the main fuel multiplier."/>
        <Data name="reserved" inMemoryType="null" encodedType="unsigned8"/>
    </Packet>

    <Packet name="TelemetryInjector" title="Telemetry Injector" ID="EFI_PKT_TELEMETRYINJECTOR" useInOtherPackets="true" comment="Operational details for injectors 1 and 2">
        <Data name="reserved" inMemoryType="null" encodedType="bitfield1"/>
        <Data name="injector1usesense1" inMemoryType="bitfield1" comment="Set if injector 1 is being triggered by sense 1"/>
        <Data name="injector1usesense2" inMemoryType="bitfield1" comment="Set if injector 1 is being triggered by sense 2"/>
        <Data name="injector1Time" inMemoryType="float32" encodedType="bitfield17" scaler="1.0" comment="First injector on time for each engine cycle in microseconds. This does not include the injector trim time."/>
        <Data name="injection1Angle" inMemoryType="float32" encodedType="bitfield10" scaler="2" comment="Crank angle of the first injection."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield1"/>
        <Data name="injector2usesense1" inMemoryType="bitfield1" comment="Set if injector 2 is being triggered by sense 1"/>
        <Data name="injector2usesense2" inMemoryType="bitfield1" comment="Set if injector 2 is being triggered by sense 2"/>
        <Data name="injector2Time" inMemoryType="float32" encodedType="bitfield17" scaler="1.0" comment="Second injector on time for each engine cycle in microseconds. This does not include the injector trim time."/>
        <Data name="injection2Angle" inMemoryType="float32" encodedType="bitfield10" scaler="2" comment="Crank angle of the second injection."/>
        <Data name="injector3usesense1" inMemoryType="bitfield1" comment="Set if injector 3 is being triggered by sense 1"/>
        <Data name="injector3usesense2" inMemoryType="bitfield1" comment="Set if injector 3 is being triggered by sense 2"/>
    </Packet>

    <Packet name="TelemetryExtendedOutputs" title="Telemetry Extended Outputs" ID="EFI_PKT_TELEMETRYEXTENDEDOUTPUTS" useInOtherPackets="true" comment="Operational details for the third injector and second and third spark">
        <Data name="sparkAdvance2" inMemoryType="float32" encodedType="bitfield10" scaler="2" comment="Spark advance in degrees for the second spark output."/>
        <Data name="sparkAdvance3" inMemoryType="float32" encodedType="bitfield10" scaler="2" comment="Spark advance in degrees for the third spark output."/>
        <Data name="injection3Angle" inMemoryType="float32" encodedType="bitfield10" scaler="2" comment="Crank angle of the third injection."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield1"/>
        <Data name="injector3Time" inMemoryType="float32" encodedType="bitfield17" scaler="1.0" comment="third injector on time for each engine cycle in microseconds. This does not include the injector trim time."/>
        <Data name="_fmChargeTemp3" inMemoryType="float32" constant="1" encodedType="unsigned8" scaler="100" comment="Deprecated in API 10, do not use"/>
        <Data name="_fmHeadTemp3" inMemoryType="float32" constant="1" encodedType="unsigned8" scaler="100" comment="Deprecated in API 10, do not use"/>
    </Packet>

    <Packet name="TelemetrySlow" title="Telemetry Slow" ID="EFI_PKT_TELEMETRYSLOW" useInOtherPackets="true"
            comment="Miscellanious telemetry, output at the slow telemetry rate. For any
                     slow output epoch this is always the last packet. Therefore you should
                     trigger display of slow packet data on receipt of this packet (or the slow summary packet).">
        <Data name="sparkAdvance1" inMemoryType="float32" encodedType="signed8" scaler="2" comment="Spark advance in degrees for the first spark output."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="spark1usesense1" inMemoryType="bitfield1" comment="Set if spark 1 is being triggered by sense 1"/>
        <Data name="spark1usesense2" inMemoryType="bitfield1" comment="Set if spark 1 is being triggered by sense 2"/>
        <Data name="spark2usesense1" inMemoryType="bitfield1" comment="Set if spark 2 is being triggered by sense 1"/>
        <Data name="spark2usesense2" inMemoryType="bitfield1" comment="Set if spark 2 is being triggered by sense 2"/>
        <Data name="spark3usesense1" inMemoryType="bitfield1" comment="Set if spark 3 is being triggered by sense 1"/>
        <Data name="spark3usesense2" inMemoryType="bitfield1" comment="Set if spark 3 is being triggered by sense 2"/>
        <Data name="power" inMemoryType="float32" encodedType="float16:10" comment="Estimated engine shaft power in Watts."/>
        <Data name="rpmControllerFromUser" inMemoryType="bitfield1" comment="Set if the RPM controller is running and gettings its command from the user."/>
        <Data name="rpmControllerFromThrottle" inMemoryType="bitfield1" comment="Set if the RPM controller is running and getting its command from the throttle input, or the throttle limiter."/>
        <Data name="rpmcmd" inMemoryType="float32" encodedType="bitfield14" scaler="1" comment="Engine speed command in revolutions per minute."/>
        <Data name="pumpduty" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Fuel pump duty cycle in percent"/>
        <Data name="cooling1" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="First cooling output in percent"/>
    </Packet>

    <Packet name="TelemetrySlowapi7" title="Telemetry Slow (api=7, deprecated)" encode="false" ID="EFI_PKT_TELEMETRYSLOW" useInOtherPackets="true"
            comment="Miscellanious telemetry, output at the slow telemetry rate. For any
                     slow output epoch this is always the last packet. Therefore you should
                     trigger display of slow packet data on receipt of this packet (or the slow summary packet).">
        <Data name="sparkAdvance1" inMemoryType="float32" encodedType="signed8" scaler="2" comment="Spark advance in degrees for the first spark output."/>
        <Data name="_sparkAdvance2" inMemoryType="float32" encodedType="signed8" scaler="2" comment="Spark advance in degrees for the second spark output."/>
        <Data name="power" inMemoryType="float32" encodedType="float16:10" comment="Estimated engine shaft power in Watts."/>
        <Data name="rpmControllerFromUser" inMemoryType="bitfield1" comment="Set if the RPM controller is running and gettings its command from the user."/>
        <Data name="rpmControllerFromThrottle" inMemoryType="bitfield1" comment="Set if the RPM controller is running and getting its command from the throttle input, or the throttle limiter."/>
        <Data name="rpmcmd" inMemoryType="float32" encodedType="bitfield14" scaler="1" comment="Engine speed command in revolutions per minute."/>
        <Data name="pumpduty" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Fuel pump duty cycle in percent"/>
        <Data name="cooling1" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="First cooling output in percent"/>
    </Packet>

    <Packet name="TelemetryCPU" title="Telemetry CPU" ID="EFI_PKT_TELEMETRYCPU" useInOtherPackets="true" comment="Run time system information including CPU loading">
        <Data name="cpuLoad" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Total cpu loading in percent"/>
        <Data name="intLoad" inMemoryType="float32" encodedType="unsigned8" scaler="10" comment="Percentage of CPU time spent in interrupts"/>
        <Data name="stack" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Percentage of available stack space that has been used"/>
        <Data name="cpuTemp" inMemoryType="float32" encodedType="signed8" scaler="1" comment="CPU temperature in C."/>
        <Data name="safeModeActive" inMemoryType="bitfield1" comment="If set the system booted in safe mode due to too many resets. No settings data were loaded from non-volatile storage in this mode. The only way to exit safe mode is to reset the system."/>
        <Data name="passwordRequired" inMemoryType="bitfield1" comment="If set the EFI requires a password to be unlocked."/>
        <Data name="unlockLevel" inMemoryType="bitfield2" comment="EFI unlock level. 0 indicates the EFI is locked, '1' indicates the EFI is partially unlocked, and '2' indicates it is password unlocked"/>
        <Data name="sdcardPresent" inMemoryType="bitfield1" comment="If set an SD card is detected and configured for data recording, and the SD card telemetry packet should be expected."/>
        <Data name="gcuPresent" inMemoryType="bitfield1" comment="If set a GCU (generator control unit) is detected on the CNA bus and the GCU telemetry packet should be expected."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2" comment="reserved bits"/>
        <Data name="watchdog" inMemoryType="usigned32" encodedType="unsigned8" scaler="0.1" comment="Maximum interval of time, in microseconds, between watchdog service events."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield3" comment="reserved bits"/>
        <Data name="api" inMemoryType="unsigned8" constant="geteficommsApi()" encodedType="bitfield5" comment="Application programming interface number. Changes to the ICD will increment this number."/>
        <Data name="interrupt" inMemoryType="usigned32" encodedType="unsigned8" comment="Maximum amount time spent in an interrupt, or with interrupts blocked, in microseconds."/>
    </Packet>

    <Packet name="TelemetryCPUapi4" title="Telemetry CPU (api=4, deprecated)" hidden="true" encode="false" ID="EFI_PKT_TELEMETRYCPU" useInOtherPackets="true" comment="Run time system information including CPU loading">
        <Data name="cpuLoad" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Total cpu loading in percent"/>
        <Data name="intLoad" inMemoryType="float32" encodedType="unsigned8" scaler="10" comment="Percentage of CPU time spent in interrupts"/>
        <Data name="stack" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Percentage of available stack space that has been used"/>
        <Data name="cpuTemp" inMemoryType="float32" encodedType="signed8" scaler="1" comment="CPU temperature in C."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield1" comment="reserved bits"/>
        <Data name="passwordRequired" inMemoryType="bitfield1" comment="If set the EFI requires a password to be unlocked."/>
        <Data name="unlockLevel" inMemoryType="bitfield2" comment="EFI unlock level. 0 indicates the EFI is locked, '1' indicates the EFI is partially unlocked, and '2' indicates it is password unlocked"/>
        <Data name="watchdog" inMemoryType="usigned32" encodedType="bitfield14" scaler="0.01" comment="Maximum interval of time, in microseconds, between watchdog service events."/>
        <Data name="interrupt" inMemoryType="bitfield14" comment="Maximum amount time spent in an interrupt, or with interrupts blocked, in microseconds."/>
    </Packet>

    <Packet name="Errors" title="Dynamic and Sticky Errors" ID="EFI_PKT_STICKY_ERRORS, EFI_PKT_TELEMETRYERRORS" useInOtherPackets="true"
         comment="Error information, output at the slow telemetry rate. There are two types of error information: dynamic errors (reported by `EFI_PKT_TELEMETRYERRORS`) and sticky errors (reported by `EFI_PKT_STICKY_ERRORS`). Dynamic errors indicate the current error condition, and will automatically clear when the error condition is resolved. Sticky errors are only cleared by sending `EFI_PKT_STICKY_ERRORS` with bits cleared where desired.">

        <Enum name="efiCrankError" comment="Enumerated list of errors that can be reported by the crank sensor">
            <Value name="EFI_CRANK_NOERROR" comment="No errors in crank sense"/>
            <Value name="EFI_CRANK_STARTSYNCERROR" comment="Crank wheel synchronization error during start. This could be a transient"/>        
            <Value name="EFI_CRANK_MISSEDEDGE" comment="Crank sense missed an edge (i.e. two edges of the same type (rising or falling) in a row)"/>
            <Value name="EFI_CRANK_OVERCAPTURE" comment="Crank sense hardware registered an overcapture, which occurs when software does not service the hardware fast enough"/>
            <Value name="EFI_CRANK_TOOFAST" comment="Crank sense active edge was earlier than expected"/>
            <Value name="EFI_CRANK_RUNSYNCERROR" comment="Crank wheel synchronization was lost after the engine was running"/>        
            <Value name="EFI_CRANK_TOOLATE" comment="Crank sense active edge was later than expected"/>
            <Value name="EFI_CRANK_REVERSED" comment="Crank is rotating in a direction that is not allowed"/>
        </Enum>

        <Data name="inputvoltagelow" inMemoryType="bitfield1" comment="Set if input voltage is too low"/>
        <Data name="inputvoltagehigh" inMemoryType="bitfield1" comment="Set if input voltage is too high"/>
        <Data name="matsensorunderrng" inMemoryType="bitfield1" comment="Set if manifold air temperature sensor is out of range low"/>
        <Data name="matsensoroverrng" inMemoryType="bitfield1" comment="Set if manifold air temperature sensor is out of range high"/>
        <Data name="cht1sensorunderrng" inMemoryType="bitfield1" comment="Set if first cylinder head temperature sensor is out of range low"/>
        <Data name="cht1sensoroverrng" inMemoryType="bitfield1" comment="Set if first cylinder head temperature sensor is out of range high"/>
        <Data name="cht2sensorunderrng" inMemoryType="bitfield1" comment="Set if second cylinder head temperature sensor is out of range low"/>
        <Data name="cht2sensoroverrng" inMemoryType="bitfield1" comment="Set if second cylinder head temperature sensor is out of range high"/>
        <Data name="mapsensorunderrng" inMemoryType="bitfield1" comment="Set if manifold air pressure sensor is out of range low"/>
        <Data name="mapsensoroverrng" inMemoryType="bitfield1" comment="Set if manifold air pressure sensor is out of range high"/>
        <Data name="fuelpsensorunderrng" inMemoryType="bitfield1" comment="Set if fuel pressure sensor is out of range low"/>
        <Data name="fuelpsensoroverrng" inMemoryType="bitfield1" comment="Set if fuel pressure sensor is out of range high"/>
        <Data name="analogtpssensorunderrng" inMemoryType="bitfield1" comment="Set if analog TPS sensor is out of range low"/>
        <Data name="analogtpssensoroverrng" inMemoryType="bitfield1" comment="Set if analog TPS is out of range high"/>
        <Data name="cputemplow" inMemoryType="bitfield1" comment="Set if CPU temperature is too low"/>
        <Data name="cputemphigh" inMemoryType="bitfield1" comment="Set if CPU temperature is too high"/>
        <Data name="sparetempsensorunderrng" inMemoryType="bitfield1" comment="Set if spare temperature sensor is out of range low"/>
        <Data name="sparetempsensoroverrng" inMemoryType="bitfield1" comment="Set if spare temperature sensor is out of range high"/>
        <Data name="barosensorunderrng" inMemoryType="bitfield1" comment="Set if barometric air pressure sensor is out of range low"/>
        <Data name="barosensoroverrng" inMemoryType="bitfield1" comment="Set if barometric air pressure sensor is out of range high"/>
        <Data name="crank1error" inMemoryType="bitfield3" comment="Enumerated errors from crank sense1, clear if no errors"/>
        <Data name="crank2error" inMemoryType="bitfield3" comment="Enumerated errors from crank sense2, clear if no errors"/>
        <Data name="cht1low" inMemoryType="bitfield1" comment="Set if the first cylinder head temperature is too low, the head is overcooled"/>
        <Data name="cht1high" inMemoryType="bitfield1" comment="Set if the first cylinder head temperature is too high, the head is overheating"/>
        <Data name="cht2low" inMemoryType="bitfield1" comment="Set if the second cylinder head temperature is too low, the head is overcooled"/>
        <Data name="cht2high" inMemoryType="bitfield1" comment="Set if the second cylinder head temperature is too high, the head is overheating"/>
        <Data name="fuelplow" inMemoryType="bitfield1" comment="Set if the fuel pressure is too low"/>
        <Data name="fuelphigh" inMemoryType="bitfield1" comment="Set if the fuel pressure is too high"/>
        <Data name="hardoverspeed" inMemoryType="bitfield1" comment="Set if the engine RPM exceeded the hard rev limit"/>
        <Data name="softoverspeed" inMemoryType="bitfield1" comment="Set if the engine RPM exceeded the soft rev limit"/>
        <Data name="parameterhash" inMemoryType="bitfield1" comment="Set if the nonvolatile parameters did not hash to the expected value"/>
        <Data name="voltage12low" inMemoryType="bitfield1" comment="Set if 12V voltage is too low"/>
        <Data name="voltage12high" inMemoryType="bitfield1" comment="Set if 12V voltage is too high"/>
        <Data name="inputcurrentlow" inMemoryType="bitfield1" comment="Set if the input current is too low"/>
        <Data name="inputcurrenthigh" inMemoryType="bitfield1" comment="Set if the input current is too high"/>
        <Data name="current12low" inMemoryType="bitfield1" comment="Set if the current of the 12 volt rail is too low"/>
        <Data name="current12high" inMemoryType="bitfield1" comment="Set if the current of the 12 volt rail too high"/>
        <Data name="power6fault" inMemoryType="bitfield1" comment="Set if the 6 volt power supply is faulted"/>
        <Data name="injector1fault" inMemoryType="bitfield1" comment="Set if the first injector has a fault"/>
        <Data name="injector2fault" inMemoryType="bitfield1" comment="Set if the second injector has a fault"/>
        <Data name="userStorageError" inMemoryType="bitfield1" comment="Set if there is a user storage error"/>
        <Data name="analogbarosensorunderrng" inMemoryType="bitfield1" comment="Set if the analog barometric air pressure sensor is out of range low"/>
        <Data name="analogbarosensoroverrng" inMemoryType="bitfield1" comment="Set if the analog barometric air pressure sensor is out of range high"/>
        <Data name="oatsensorunderrng" inMemoryType="bitfield1" comment="Set if barometric air pressure sensor is out of range low"/>
        <Data name="oatsensoroverrng" inMemoryType="bitfield1" comment="Set if barometric air pressure sensor is out of range high"/>
        <Data name="canThrottleMissing" inMemoryType="bitfield1" comment="Set if the throttle is configured to use a CAN servo, but the CAN servo has not been detected on the bus"/>
        <Data name="canThrottleError" inMemoryType="bitfield1" comment="Set if the CAN throttle servo has an error bit set"/>
        <Data name="canCooling1Missing" inMemoryType="bitfield1" comment="Set if the cooling output 1 is configured to use a CAN servo, but the CAN servo has not been detected on the bus"/>
        <Data name="canCooling1Error" inMemoryType="bitfield1" comment="Set if the CAN cooling 1 servo has an error bit set"/>
        <Data name="maxstartthrottle" inMemoryType="bitfield1" comment="Set if throttle was greater than the maximum start throttle while the engine was cranking for start. In that case spark and injector outputs are suspended."/>
        <Data name="maplow" inMemoryType="bitfield1" comment="Set if manifold air pressure sensor is low compared to the estimate"/>
        <Data name="maphigh" inMemoryType="bitfield1" comment="Set if manifold air pressure sensor is high compared to the estimate"/>
        <Data name="tpsmissing" inMemoryType="bitfield1" comment="Set if there is no throttle position source, but the system is configured for one."/>
        <Data name="tpserror" inMemoryType="bitfield1" comment="Set if there is a problem with the throttle position sensor: either it is invalid (none connected to analog or PWM), or it disagrees with the throttle output (if efi drives throttle)."/>
        <Data name="sdcarderror" inMemoryType="bitfield1" comment="Set if an error occurred with the SD card recording. This error will only assert after the SD card has been successfully detected."/>
        <Data name="reserved1" inMemoryType="bitfield1" comment="Reserved for future expansion"/>
        <Data name="canCooling2Missing" inMemoryType="bitfield1" comment="Set if the cooling output 2 is configured to use a CAN servo, but the CAN servo has not been detected on the bus"/>
        <Data name="canCooling2Error" inMemoryType="bitfield1" comment="Set if the CAN cooling 2 servo has an error bit set"/>
        <Data name="maintenanceNeeded" inMemoryType="bitfield1" comment="If set a maintenance item has been triggered, see the maintenance packet for details."/>
        <Data name="testModeActive" inMemoryType="bitfield1" comment="If set the EFI is in test mode or is autocalibrating the throttle servo, refer to packet EFI_PKT_TESTMODE"/>
    </Packet>

    <Packet name="Errorsapi4" title="Dynamic and Sticky Errors for api 4, deprecated" hidden="true" encode="false" ID="EFI_PKT_STICKY_ERRORS, EFI_PKT_TELEMETRYERRORS" useInOtherPackets="true"
         comment="Error information, output at the slow telemetry rate. There are two types of error information: dynamic errors (reported by `EFI_PKT_TELEMETRYERRORS`) and sticky errors (reported by `EFI_PKT_STICKY_ERRORS`). Dynamic errors indicate the current error condition, and will automatically clear when the error condition is resolved. Sticky errors are only cleared by sending `EFI_PKT_STICKY_ERRORS` with bits cleared where desired.">
        <Data name="inputvoltagelow" inMemoryType="bitfield1" comment="Set if input voltage is too low"/>
        <Data name="inputvoltagehigh" inMemoryType="bitfield1" comment="Set if input voltage is too high"/>
        <Data name="matsensorunderrng" inMemoryType="bitfield1" comment="Set if manifold air temperature sensor is out of range low"/>
        <Data name="matsensoroverrng" inMemoryType="bitfield1" comment="Set if manifold air temperature sensor is out of range high"/>
        <Data name="cht1sensorunderrng" inMemoryType="bitfield1" comment="Set if first cylinder head temperature sensor is out of range low"/>
        <Data name="cht1sensoroverrng" inMemoryType="bitfield1" comment="Set if first cylinder head temperature sensor is out of range high"/>
        <Data name="cht2sensorunderrng" inMemoryType="bitfield1" comment="Set if second cylinder head temperature sensor is out of range low"/>
        <Data name="cht2sensoroverrng" inMemoryType="bitfield1" comment="Set if second cylinder head temperature sensor is out of range high"/>
        <Data name="mapsensorunderrng" inMemoryType="bitfield1" comment="Set if manifold air pressure sensor is out of range low"/>
        <Data name="mapsensoroverrng" inMemoryType="bitfield1" comment="Set if manifold air pressure sensor is out of range high"/>
        <Data name="fuelpsensorunderrng" inMemoryType="bitfield1" comment="Set if fuel pressure sensor is out of range low"/>
        <Data name="fuelpsensoroverrng" inMemoryType="bitfield1" comment="Set if fuel pressure sensor is out of range high"/>
        <Data name="analogtpssensorunderrng" inMemoryType="bitfield1" comment="Set if analog TPS sensor is out of range low"/>
        <Data name="analogtpssensoroverrng" inMemoryType="bitfield1" comment="Set if analog TPS is out of range high"/>
        <Data name="cputemplow" inMemoryType="bitfield1" comment="Set if CPU temperature is too low"/>
        <Data name="cputemphigh" inMemoryType="bitfield1" comment="Set if CPU temperature is too high"/>
        <Data name="sparetempsensorunderrng" inMemoryType="bitfield1" comment="Set if spare temperature sensor is out of range low"/>
        <Data name="sparetempsensoroverrng" inMemoryType="bitfield1" comment="Set if spare temperature sensor is out of range high"/>
        <Data name="barosensorunderrng" inMemoryType="bitfield1" comment="Set if barometric air pressure sensor is out of range low"/>
        <Data name="barosensoroverrng" inMemoryType="bitfield1" comment="Set if barometric air pressure sensor is out of range high"/>
        <Data name="oatsensorunderrng" inMemoryType="bitfield1" comment="Set if barometric air pressure sensor is out of range low"/>
        <Data name="oatsensoroverrng" inMemoryType="bitfield1" comment="Set if barometric air pressure sensor is out of range high"/>
        <Data name="crank1bounce" inMemoryType="bitfield1" comment="Set if the first crank sensor detected a signal bounce (crank sense event too fast)"/>
        <Data name="crank2bounce" inMemoryType="bitfield1" comment="Set if the second crank sensor detected a signal bounce (crank sense event too fast)"/>
        <Data name="crank1late" inMemoryType="bitfield1" comment="Set if the first crank sensor is late in firing relative to the second crank sensor."/>
        <Data name="crank2late" inMemoryType="bitfield1" comment="Set if the second crank sensor is late in firing relative to the first crank sensor."/>
        <Data name="cht1low" inMemoryType="bitfield1" comment="Set if the first cylinder head temperature is too low, the head is overcooled"/>
        <Data name="cht1high" inMemoryType="bitfield1" comment="Set if the first cylinder head temperature is too high, the head is overheating"/>
        <Data name="cht2low" inMemoryType="bitfield1" comment="Set if the second cylinder head temperature is too low, the head is overcooled"/>
        <Data name="cht2high" inMemoryType="bitfield1" comment="Set if the second cylinder head temperature is too high, the head is overheating"/>
        <Data name="fuelplow" inMemoryType="bitfield1" comment="Set if the fuel pressure is too low"/>
        <Data name="fuelphigh" inMemoryType="bitfield1" comment="Set if the fuel pressure is too high"/>
        <Data name="hardoverspeed" inMemoryType="bitfield1" comment="Set if the engine RPM exceeded the hard rev limit"/>
        <Data name="softoverspeed" inMemoryType="bitfield1" comment="Set if the engine RPM exceeded the soft rev limit"/>
        <Data name="parameterhash" inMemoryType="bitfield1" comment="Set if the nonvolatile parameters did not hash to the expected value"/>
        <Data name="voltage12low" inMemoryType="bitfield1" comment="Set if 12V voltage is too low"/>
        <Data name="voltage12high" inMemoryType="bitfield1" comment="Set if 12V voltage is too high"/>
        <Data name="inputcurrentlow" inMemoryType="bitfield1" comment="Set if the input current is too low"/>
        <Data name="inputcurrenthigh" inMemoryType="bitfield1" comment="Set if the input current is too high"/>
        <Data name="current12low" inMemoryType="bitfield1" comment="Set if the current of the 12 volt rail is too low"/>
        <Data name="current12high" inMemoryType="bitfield1" comment="Set if the current of the 12 volt rail too high"/>
        <Data name="power6fault" inMemoryType="bitfield1" comment="Set if the 6 volt power supply is faulted"/>
        <Data name="injector1fault" inMemoryType="bitfield1" comment="Set if the first injector has a fault"/>
        <Data name="injector2fault" inMemoryType="bitfield1" comment="Set if the second injector has a fault"/>
        <Data name="reserved" inMemoryType="null" default="0" encodedType="bitfield1"/>
        <Data name="analogbarosensorunderrng" inMemoryType="bitfield1" comment="Set if the analog barometric air pressure sensor is out of range low"/>
        <Data name="analogbarosensoroverrng" inMemoryType="bitfield1" comment="Set if the analog barometric air pressure sensor is out of range high"/>
        <Data name="crank1missededge" inMemoryType="bitfield1" comment="Set if the first crank sensor missed an edge of the crank sense signal (i.e. two edges of the same type (rising or falling) in a row)"/>
        <Data name="crank2missededge" inMemoryType="bitfield1" comment="Set if the second crank sensor missed an edge of the crank sense signal (i.e. two edges of the same type (rising or falling) in a row)"/>
        <Data name="canThrottleMissing" inMemoryType="bitfield1" comment="Set if the throttle is configured to use a CAN servo, but the CAN servo has not been detected on the bus"/>
        <Data name="canThrottleError" inMemoryType="bitfield1" comment="Set if the CAN throttle servo has an error bit set"/>
        <Data name="canCoolingMissing" inMemoryType="bitfield1" comment="Set if the cooling output is configured to use a CAN servo, but the CAN servo has not been detected on the bus"/>
        <Data name="canCoolingError" inMemoryType="bitfield1" comment="Set if the CAN cooling servo has an error bit set"/>
        <Data name="reserved" inMemoryType="null" default="0" encodedType="bitfield1"/>
        <Data name="maplow" inMemoryType="bitfield1" comment="Set if manifold air pressure sensor is low compared to the estimate"/>
        <Data name="maphigh" inMemoryType="bitfield1" comment="Set if manifold air pressure sensor is high compared to the estimate"/>
        <Data name="tpsmissing" inMemoryType="bitfield1" comment="Set if there is no throttle position source, but the system is configured for one."/>
        <Data name="tpserror" inMemoryType="bitfield1" comment="Set if there is a problem with the throttle position sensor: either it is invalid (none connected to analog or PWM), or it disagrees with the throttle output (if efi drives throttle)."/>
        <Data name="reserved" inMemoryType="null" default="0" encodedType="bitfield4"/>
        <Data name="maintenanceNeeded" inMemoryType="bitfield1" comment="If set a maintenance item has been triggered, see the maintenance packet for details."/>
        <Data name="testModeActive" inMemoryType="bitfield1" comment="If set the EFI is in test mode, refer to packet EFI_PKT_TESTMODE"/>
    </Packet>

    <Packet name="EngineWear" title="Engine Wear" ID="EFI_PKT_ENGINEWEAR" useInOtherPackets="true" comparefile="compare/eficompareutil" printfile="compare/efiprintutil" comment="Information about engine wear, output at the slow telemetry rate.">
        <Data name="hobbs" inMemoryType="unsigned32" comment="Total engine run time in seconds"/>
        <Data name="revcount" inMemoryType="unsigned32" comment="Total number of revolutions the engine has made"/>
        <Data name="hotTime" inMemoryType="unsigned32" encodedType="bitfield20" scaler="0.1" comment="Seconds the engine has spent running above the CHT limit"/>
        <Data name="highLoadTime" inMemoryType="unsigned32" encodedType="bitfield20" scaler="0.1" comment="Seconds the engine has spent running at high load (throttle greater than 80%)."/>
        <Data name="peakCHT" inMemoryType="float32" encodedType="unsigned8" scaler="0.5" comment="Highest head temperature observed while the engine was running"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield4"/>
        <Data name="numStarts" inMemoryType="unsigned16" encodedType="bitfield12" comment="Number of times the engine has started"/>
    </Packet>

    <Packet name="EngineWearShort" title="Short Engine Wear" ID="EFI_PKT_ENGINEWEAR" useInOtherPackets="true" parameterInterface="true" comment="Short information about engine wear, output at the slow telemetry rate over the CAN bus.">
        <Data name="hobbs" inMemoryType="unsigned32" comment="Total engine run time in seconds"/>
        <Data name="revcount" inMemoryType="unsigned32" comment="Total number of revolutions the engine has made"/>
    </Packet>

    <Packet name="EngineWearExtended" redefine="EngineWear" title="Extended Engine Wear" ID="EFI_PKT_ENGINEWEAREXT"  parameterInterface="true" comment="Engine wear information beyond just hobbs and revcount, output at the slow telemetry rate over the CAN bus. This packet, in combination with `EngineWearShort` is equivalent to the full `EngineWear` packet.">
        <Data name="hotTime" inMemoryType="unsigned32" encodedType="bitfield20" scaler="0.1" comment="Seconds the engine has spent running above the CHT limit"/>
        <Data name="highLoadTime" inMemoryType="unsigned32" encodedType="bitfield20" scaler="0.1" comment="Seconds the engine has spent running at high load (throttle greater than 80%)."/>
        <Data name="peakCHT" inMemoryType="float32" encodedType="unsigned8" scaler="0.5" comment="Highest head temperature observed while the engine was running"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield4"/>
        <Data name="numStarts" inMemoryType="unsigned16" encodedType="bitfield12" comment="Number of times the engine has started"/>
    </Packet>

    <Packet name="TelemetryComms" title="Telemetry about communications" ID="EFI_PKT_TELEMETRYCOMMS" useInOtherPackets="true" comment="Information about communications performance and configuration, output at the slow telemetry rate.">
        <Enum name="efiCANerr" title="CAN errors" lookupTitle="true" comment="Enumeration of CAN bus errors">
            <Value name="EFI_CANERR_NONE" title="No error" comment="No error"/>
            <Value name="EFI_CANERR_STUFF" title="Stuff" comment="Bit stuff error (more than 5 consecutive bits the same)"/>
            <Value name="EFI_CANERR_FORM" title="Form" comment="Form error"/>
            <Value name="EFI_CANERR_ACK" title="Acknowledgement" comment="Frame acknowledgement error"/>
            <Value name="EFI_CANERR_BITREC" title="Bit recessive" comment="Bit recessive error"/>
            <Value name="EFI_CANERR_BITDOM" title="Bit dominant" comment="Bit dominant error"/>
            <Value name="EFI_CANERR_CRC" title="CRC" comment="CRC error"/>
            <Value name="EFI_CANERR_SOFT" title="Software" comment="Software error"/>
        </Enum>
        <Data name="canREC" inMemoryType="unsigned8" comment="The receive error counter from the CAN bus hardware"/>
        <Data name="canTEC" inMemoryType="unsigned8" comment="The least significant 8 bits of the transmit error counter from the CAN bus hardware"/>
        <Data name="lastCANerr" enum="efiCANerr" encodedType="bitfield3" comment="Cause of the last CAN error"/>
        <Data name="canBOF" inMemoryType="bitfield1" comment="This bit is set when the CAN hardware enters the bus-off state. The bus-off state is entered on canTEC overflow, greater than 255"/>
        <Data name="canEPVF" inMemoryType="bitfield1" comment="This bit is set when the CAN error passive limit has been reached (canREC or canTEC greater than 127)."/>
        <Data name="canEWGF" inMemoryType="bitfield1" comment="This bit is set when the CAN warning limit has been reached (canREC or canTEC greater than 95)."/>
        <Data name="canDisableNativeInput" inMemoryType="bitfield1" comment="This bit echos the CAN configuration bit `disableNativeInput`. If set then native CAN packets cannot be sent to this EFI (except possibly using the broadcast ID)."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield1"/>
        <Data name="canDisableNativeOutput" inMemoryType="bitfield1" comment="This bit echos the CAN configuration bit `disableNativeOutput`. If set then native CAN packets will not be sent by this EFI."/>
        <Data name="canDisableNativeBroadcast" inMemoryType="bitfield1" comment="This bit echos the CAN configuration bit `disableNativeBroadcast`. If set then native CAN packets cannot be sent to this EFI using the broadcast ID."/>
        <Data name="canForcePacketOverCAN" inMemoryType="bitfield1" comment="This bit echos the CAN configuration bit `forcePacketOverCAN`. If set any CAN packets sent to this EFI must use the packet-over-CAN schema, otherwise they will be ignored."/>
        <Data name="canCmdAndTmOnly" inMemoryType="bitfield1" comment="This bit echos the CAN configuration bit `cmdAndTmOnly`. If set then only commands and telemetry are supported on the CAN bus (configuration request or change will be ignored)."/>
        <Data name="canTxFull" inMemoryType="bitfield1" comment="Set if the transmit buffer of the CAN interface is full."/>
        <Data name="canPacketFailureCnt" inMemoryType="unsigned8" encodedType="bitfield3" comment="Number of packets received over the CAN bus which were invalid (bad CRC) since the last time this packet was output"/>
        <Data name="uartTxFull" inMemoryType="bitfield1" comment="Set if the transmit buffer of the UART interface is full."/>
        <Data name="uartPacketFailureCnt" inMemoryType="unsigned8" encodedType="bitfield3" comment="Number of packets received over the UART which were invalid (bad CRC) since the last time this packet was output"/>
        <Data name="usbTxFull" inMemoryType="bitfield1" comment="Set if the transmit buffer of the USB interface is full."/>
        <Data name="usbPacketFailureCnt" inMemoryType="unsigned8" encodedType="bitfield3" comment="Number of packets received over the USB which were invalid (bad CRC) since the last time this packet was output"/>
        <Data name="txCANPacketCounter" inMemoryType="unsigned8" comment="Free running counter of packets transmitted over CAN (not counting this packet)."/>
        <Data name="txPacketCounter" inMemoryType="unsigned8" comment="Free running counter of packets transmitted over the UART or USB (not counting this packet)."/>
        <Data name="rxPacketCounter" inMemoryType="unsigned8" comment="Free running counter for received packets (from any source)."/>
    </Packet>

    <Packet name="TelemetryAutoFuel" title="Automatic Fuel" hidden="true" ID="EFI_PKT_TELEMETRYAUTOFUEL" comment="Automatic fuel determination packet. This packet reports the results of the autofuel algorithm, each time it runs.">
        <Data name="correlation" inMemoryType="float32" encodedType="float16:10" comment="Correlation value between fuel multiplier and specific power."/>
        <Data name="coefficient" inMemoryType="float32" encodedType="unsigned8" scaler="200" comment="Pearson's correlation coefficient from 0.0 to 1.0"/>
        <Data name="timedelay" inMemoryType="float32" encodedType="unsigned8" scaler="20" comment="Time delay in seconds for maximum correlation magnitude."/>
        <Data name="reserved" inMemoryType="null" encodedType="unsigned32"/>
    </Packet>

    <Enum name="efiSDStatus" title="SD Status" lookupTitle="true" comment="SD Card status">
        <Value name="EFI_SD_HARDWARE_BAD" title="SD bad card" comment="The SD card has not been detected; it may be missing, or the hardware may be bad."/>
        <Value name="EFI_SD_MBR_BAD" title="SD bad boot" comment="The SD card does not have a valid boot sector, it needs formatting."/>
        <Value name="EFI_SD_VOLUME_BAD" title="SD bad volume" comment="The SD card does not have a valid volume sector, it needs formatting."/>
        <Value name="EFI_SD_ROOT_BAD" title="SD bad root" comment="The SD card does not have the expected root directory layout, it needs directory setup."/>
        <Value name="EFI_SD_FORMATTING" title="SD formatting" comment="The SD card is being formatted. This status is always followed by `EFI_SD_SETTINGUP`."/>
        <Value name="EFI_SD_SETTINGUP" title="SD setting up" comment="The SD card root directory is being setup."/>
        <Value name="EFI_SD_READY" title="SD ready" comment="The SD card is ready to record."/>
        <Value name="EFI_SD_TRANSFER" title="SD transferring" comment="The SD card is reporting recorded data."/>
    </Enum>
    
    <Packet name="TelemetrySDCard" title="SD card telemetry" ID="EFI_PKT_TELEMETRYSDCARD" useInOtherPackets="true" comment="Telemetry about the SD card. This packet is only sent if the SD card is present. Presence of the SD card is always visible in the [CPU telemetry](#EFI_PKT_TELEMETRYCPU) packet.">
        <Data name="sdstatus" enum="efiSDStatus" encodedType="bitfield3" comment="Status of the SD card"/>
        <Data name="errorCount" inMemoryType="unsigned8" encodedType="bitfield5" comment="The number of SD card errors experienced since bootup."/>
        <Data name="sequence" inMemoryType="unsigned32" encodedType="unsigned24" comment="If `sdstatus` is `EFI_SD_READY` this is the number of 512-byte blocks that have been written to the card since the system booted up. If `sdstatus` is `EFI_SD_SETTINGUP` this gives the progress of the directory setup in tenths of a percent. If `sdstatus` is `EFI_SD_TRANSFER` this gives the progress of the transfer in tenths of a percent. In all other states this value is zero."/>
        <Data name="numDataBlocks" inMemoryType="unsigned32" comment="The total number of data blocks that have been written to the card, this does not include the journal blocks."/>
    </Packet>

    <Packet name="TelemetryOilInjection" title="Oil Injection Telemetry" ID="EFI_PKT_TELEMETRYOILINJ" comment="Telemetry about the oil injection system. The oil injection system must be enabled in the injector configuration. If oil injection is not enabled this packet will not be sent.">
        <Data name="oilFlowRate" inMemoryType="float32" encodedType="float16:10" comment="Oil flow rate in grams per minute."/>
        <Data name="oilConsumption" inMemoryType="float32" encodedType="float16:10" comment="Oil consumption in grams since the system turned on."/>
        <Data name="oilDuty" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Oil injector pump duty cycle in percent"/>
        <Data name="oilFreq" inMemoryType="float32" encodedType="unsigned8" scaler="10" comment="Oil injector pump frequency in Hz"/>
        <Data name="oilPrimeLeft" inMemoryType="unsigned16" encodedType="unsigned8" scaler="0.05" comment="Number of oil injection priming pulses remaining, zero if priming is off"/>
        <Data name="reserved" inMemoryType="null" encodedType="unsigned8"/>
    </Packet>

    <Packet name="TelemetryGCU" title="GCU Telemetry" ID="EFI_PKT_TELEMETRYGCU" comment="Telemetry about the Generator Control Unit (GCU). The GCU is external hardware that sends status information on the CAN bus. This packet is only sent by IntelliJect if the GCU data are detected on the CAN bus. Detection of the GCU is always visible in the [CPU telemetry](#EFI_PKT_TELEMETRYCPU) packet.">
        <Enum name="gcuSource" title="Source of GCU information" lookupTitle="true">
            <Value name="NWGCU" title="Northwest GCU"/>
            <Value name="MWPMU" title="Millswood PMU"/>
            <Value name="P4FGEN" title="P4F Generator"/>
        </Enum>
        <Data name="source" enum="gcuSource" encodedType="bitfield2" comment="Enumeration describing the source of the GCU information"/>
        <Data name="volts28" inMemoryType="float32" encodedType="bitfield14" scaler="100" comment="Voltage of the 28 V rail"/>
        <Data name="volts12" inMemoryType="float32" encodedType="bitfield12" scaler="100" comment="Voltage of the 12 V rail"/>
        <Data name="volts6" inMemoryType="float32" encodedType="bitfield12" scaler="100"  comment="Voltage of the 6 V rail"/>
        <Data name="gcuTemp" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="Internal temperature of the GCU in Celsius"/>
        <Data name="cranking" inMemoryType="bitfield1" comment="Set if the GCU is cranking the engine for start"/>
        <Data name="generating" inMemoryType="bitfield1" comment="Set if the GCU is making electricity from the generator"/>
        <Data name="charging" inMemoryType="bitfield1" comment="Set if the GCU is charging the battery"/>
        <Data name="startAvailable" inMemoryType="bitfield1" comment="Set if the GCU starter is available"/>
        <Data name="current28" inMemoryType="float32" encodedType="bitfield12" scaler="100" comment="Current in Amps of the 28 V rail"/>
    </Packet>

    <Packet name="TelemetrySlowSummaryapi0" title="Slow Telemetry Summary Packet (api=0, deprecated)" encode="false" hidden="true" ID="EFI_PKT_TELEMETRYSLOWSUM" parameterInterface="true" comment="Summary packet that contains all the slow telemetry in a single packet. The summary packet is only used on non-CAN interfaces (unless `forcePacketOverCAN` is set), and only if it is enabled in the communications configuration. Since each ordinary telemetry packet is only 8 bytes long, combining multiple telmetry packets into a single summary packet can significantly reduce packet overhead.">
        <Data name="time" struct="TelemetryTime" comment="Time information for the slow telemetry"/>
        <Data name="sensors" struct="TelemetrySensorsapi7" comment="First set of sensor information"/>
        <Data name="sensors2" struct="TelemetrySensors2api7" comment="Second set of sensor information"/>
        <Data name="fuel" struct="TelemetryFuel" comment="Fuel flow and fuel used information"/>
        <Data name="injector" struct="TelemetryInjector" comment="Injector(s) information"/>
        <Data name="slow" struct="TelemetrySlowapi7" comment="Slow telemetry data"/>
        <Data name="cpu" struct="TelemetryCPUapi4" comment="Run time CPU information"/>
        <Data name="sensors3" struct="TelemetrySensors3api0" comment="Third set of sensor information"/>
        <Data name="dynamicError" struct="Errorsapi4" comment="Dynamic engine errors"/>
        <Data name="stickyError" struct="Errorsapi4" comment="Sticky engine errors"/>
        <Data name="wear" struct="EngineWearShort" comment="Short engine wear information"/>
    </Packet>

    <Packet name="TelemetrySlowSummaryapi1" title="Slow Telemetry Summary Packet (api=1, deprecated)" encode="false" hidden="true" ID="EFI_PKT_TELEMETRYSLOWSUM" parameterInterface="true" comment="Summary packet that contains all the slow telemetry in a single packet. The summary packet is only used on non-CAN interfaces (unless `forcePacketOverCAN` is set), and only if it is enabled in the communications configuration. Since each ordinary telemetry packet is only 8 bytes long, combining multiple telmetry packets into a single summary packet can significantly reduce packet overhead.">
        <Data name="time" struct="TelemetryTime" comment="Time information for the slow telemetry"/>
        <Data name="sensors" struct="TelemetrySensorsapi7" comment="First set of sensor information"/>
        <Data name="sensors2" struct="TelemetrySensors2api7" comment="Second set of sensor information"/>
        <Data name="fuel" struct="TelemetryFuel" comment="Fuel flow and fuel used information"/>
        <Data name="injector" struct="TelemetryInjector" comment="Injector(s) information"/>
        <Data name="slow" struct="TelemetrySlowapi7" comment="Slow telemetry data"/>
        <Data name="cpu" struct="TelemetryCPUapi4" comment="Run time CPU information"/>
        <Data name="sensors3" struct="TelemetrySensors3" comment="Third set of sensor information"/>
        <Data name="dynamicError" struct="Errorsapi4" comment="Dynamic engine errors"/>
        <Data name="stickyError" struct="Errorsapi4" comment="Sticky engine errors"/>
        <Data name="wear" struct="EngineWearShort" comment="Short engine wear information"/>
    </Packet>

    <Packet name="TelemetrySlowSummaryapi2" title="Slow Telemetry Summary Packet (api=2, deprecated)" encode="false" hidden="true" ID="EFI_PKT_TELEMETRYSLOWSUM" parameterInterface="true" comment="Summary packet that contains all the slow telemetry in a single packet. The summary packet is only used on non-CAN interfaces (unless `forcePacketOverCAN` is set), and only if it is enabled in the communications configuration. Since each ordinary telemetry packet is only 8 bytes long, combining multiple telmetry packets into a single summary packet can significantly reduce packet overhead.">
        <Data name="time" struct="TelemetryTime" comment="Time information for the slow telemetry"/>
        <Data name="sensors" struct="TelemetrySensorsapi7" comment="First set of sensor information"/>
        <Data name="sensors2" struct="TelemetrySensors2api7" comment="Second set of sensor information"/>
        <Data name="fuel" struct="TelemetryFuel" comment="Fuel flow and fuel used information"/>
        <Data name="injector" struct="TelemetryInjector" comment="Injector(s) information"/>
        <Data name="slow" struct="TelemetrySlowapi7" comment="Slow telemetry data"/>
        <Data name="cpu" struct="TelemetryCPUapi4" comment="Run time CPU information"/>
        <Data name="sensors3" struct="TelemetrySensors3" comment="Third set of sensor information"/>
        <Data name="dynamicError" struct="Errorsapi4" comment="Dynamic engine errors"/>
        <Data name="stickyError" struct="Errorsapi4" comment="Sticky engine errors"/>
        <Data name="wear" struct="EngineWearShort" comment="Short engine wear information"/>
        <Data name="comms" struct="TelemetryComms" comment="Communications error and performance information"/>
    </Packet>

    <Packet name="TelemetrySlowSummaryapi3" title="Slow Telemetry Summary Packet (api=3, deprecated)" encode="false" hidden="true" ID="EFI_PKT_TELEMETRYSLOWSUM" parameterInterface="true" comment="Summary packet that contains all the slow telemetry in a single packet. The summary packet is only used on non-CAN interfaces (unless `forcePacketOverCAN` is set), and only if it is enabled in the communications configuration. Since each ordinary telemetry packet is only 8 bytes long, combining multiple telmetry packets into a single summary packet can significantly reduce packet overhead.">
        <Data name="time" struct="TelemetryTime" comment="Time information for the slow telemetry"/>
        <Data name="sensors" struct="TelemetrySensorsapi7" comment="First set of sensor information"/>
        <Data name="sensors2" struct="TelemetrySensors2api7" comment="Second set of sensor information"/>
        <Data name="fuel" struct="TelemetryFuel" comment="Fuel flow and fuel used information"/>
        <Data name="injector" struct="TelemetryInjector" comment="Injector(s) information"/>
        <Data name="slow" struct="TelemetrySlowapi7" comment="Slow telemetry data"/>
        <Data name="cpu" struct="TelemetryCPUapi4" comment="Run time CPU information"/>
        <Data name="sensors3" struct="TelemetrySensors3" comment="Third set of sensor information"/>
        <Data name="dynamicError" struct="Errorsapi4" comment="Dynamic engine errors"/>
        <Data name="stickyError" struct="Errorsapi4" comment="Sticky engine errors"/>
        <Data name="wear" struct="EngineWearShort" comment="Short engine wear information"/>
        <Data name="comms" struct="TelemetryComms" comment="Communications error and performance information"/>
        <Data name="sensors4" struct="TelemetrySensors4" comment="Fourth set of sensor information"/>
    </Packet>

    <Packet name="TelemetrySlowSummaryapi4" title="Slow Telemetry Summary Packet (api=4, deprecated)" encode="false" hidden="true" ID="EFI_PKT_TELEMETRYSLOWSUM" parameterInterface="true" comment="Summary packet that contains all the slow telemetry in a single packet. The summary packet is only used on non-CAN interfaces (unless `forcePacketOverCAN` is set), and only if it is enabled in the communications configuration. Since each ordinary telemetry packet is only 8 bytes long, combining multiple telmetry packets into a single summary packet can significantly reduce packet overhead.">
        <Data name="time" struct="TelemetryTime" comment="Time information for the slow telemetry"/>
        <Data name="sensors" struct="TelemetrySensorsapi7" comment="First set of sensor information"/>
        <Data name="sensors2" struct="TelemetrySensors2api7" comment="Second set of sensor information"/>
        <Data name="fuel" struct="TelemetryFuel" comment="Fuel flow and fuel used information"/>
        <Data name="injector" struct="TelemetryInjector" comment="Injector(s) information"/>
        <Data name="slow" struct="TelemetrySlowapi7" comment="Slow telemetry data"/>
        <Data name="cpu" struct="TelemetryCPUapi4" comment="Run time CPU information"/>
        <Data name="sensors3" struct="TelemetrySensors3" comment="Third set of sensor information"/>
        <Data name="dynamicError" struct="Errorsapi4" comment="Dynamic engine errors"/>
        <Data name="stickyError" struct="Errorsapi4" comment="Sticky engine errors"/>
        <Data name="wear" struct="EngineWear" comment="Engine wear information"/>
        <Data name="comms" struct="TelemetryComms" comment="Communications error and performance information"/>
        <Data name="sensors4" struct="TelemetrySensors4" comment="Fourth set of sensor information"/>
    </Packet>

    <Packet name="TelemetrySlowSummaryapi5" title="Slow Telemetry Summary Packet (api=5, deprecated)" encode="false" hidden="true" ID="EFI_PKT_TELEMETRYSLOWSUM" parameterInterface="true" comment="Summary packet that contains all the slow telemetry in a single packet. The summary packet is only used on non-CAN interfaces (unless `forcePacketOverCAN` is set), and only if it is enabled in the communications configuration. Since each ordinary telemetry packet is only 8 bytes long, combining multiple telmetry packets into a single summary packet can significantly reduce packet overhead.">
        <Data name="time" struct="TelemetryTime" comment="Time information for the slow telemetry"/>
        <Data name="sensors" struct="TelemetrySensorsapi7" comment="First set of sensor information"/>
        <Data name="sensors2" struct="TelemetrySensors2api7" comment="Second set of sensor information"/>
        <Data name="fuel" struct="TelemetryFuel" comment="Fuel flow and fuel used information"/>
        <Data name="injector" struct="TelemetryInjector" comment="Injector(s) information"/>
        <Data name="slow" struct="TelemetrySlowapi7" comment="Slow telemetry data"/>
        <Data name="cpu" struct="TelemetryCPU" comment="Run time CPU information"/>
        <Data name="sensors3" struct="TelemetrySensors3" comment="Third set of sensor information"/>
        <Data name="dynamicError" struct="Errors" comment="Dynamic engine errors"/>
        <Data name="stickyError" struct="Errors" comment="Sticky engine errors"/>
        <Data name="wear" struct="EngineWear" comment="Engine wear information"/>
        <Data name="comms" struct="TelemetryComms" comment="Communications error and performance information"/>
        <Data name="sensors4" struct="TelemetrySensors4" comment="Fourth set of sensor information"/>
    </Packet>

    <Packet name="TelemetrySlowSummaryapi7" title="Slow Telemetry Summary Packet (api=7, deprecated)" encode="false" hidden="true" ID="EFI_PKT_TELEMETRYSLOWSUM" parameterInterface="true" comment="Summary packet that contains all the slow telemetry in a single packet. The summary packet is only used on non-CAN interfaces (unless `forcePacketOverCAN` is set), and only if it is enabled in the communications configuration. Since each ordinary telemetry packet is only 8 bytes long, combining multiple telmetry packets into a single summary packet can significantly reduce packet overhead.">
        <Data name="time" struct="TelemetryTime" comment="Time information for the slow telemetry"/>
        <Data name="sensors" struct="TelemetrySensorsapi7" comment="First set of sensor information"/>
        <Data name="sensors2" struct="TelemetrySensors2api7" comment="Second set of sensor information"/>
        <Data name="fuel" struct="TelemetryFuel" comment="Fuel flow and fuel used information"/>
        <Data name="injector" struct="TelemetryInjector" comment="Injector(s) information"/>
        <Data name="slow" struct="TelemetrySlowapi7" comment="Slow telemetry data"/>
        <Data name="cpu" struct="TelemetryCPU" comment="Run time CPU information"/>
        <Data name="sensors3" struct="TelemetrySensors3" comment="Third set of sensor information"/>
        <Data name="dynamicError" struct="Errors" comment="Dynamic engine errors"/>
        <Data name="stickyError" struct="Errors" comment="Sticky engine errors"/>
        <Data name="wear" struct="EngineWear" comment="Engine wear information"/>
        <Data name="comms" struct="TelemetryComms" comment="Communications error and performance information"/>
        <Data name="sensors4" struct="TelemetrySensors4" comment="Fourth set of sensor information"/>
        <Data name="sdcard" struct="TelemetrySDCard" comment="SD Card telemetry information"/>
    </Packet>

    <Packet name="TelemetrySlowSummary" title="Slow Telemetry Summary Packet" ID="EFI_PKT_TELEMETRYSLOWSUM" parameterInterface="true" comment="Summary packet that contains all the slow telemetry in a single packet. The summary packet is only used on non-CAN interfaces (unless `forcePacketOverCAN` is set), and only if it is enabled in the communications configuration. Since each ordinary telemetry packet is only 8 bytes long, combining multiple telmetry packets into a single summary packet can significantly reduce packet overhead.">
        <Data name="time" struct="TelemetryTime" comment="Time information for the slow telemetry"/>
        <Data name="sensors" struct="TelemetrySensors" comment="First set of sensor information"/>
        <Data name="sensors2" struct="TelemetrySensors2" comment="Second set of sensor information"/>
        <Data name="fuel" struct="TelemetryFuel" comment="Fuel flow and fuel used information"/>
        <Data name="injector" struct="TelemetryInjector" comment="Injector(s) information"/>
        <Data name="slow" struct="TelemetrySlow" comment="Slow telemetry data"/>
        <Data name="cpu" struct="TelemetryCPU" comment="Run time CPU information"/>
        <Data name="sensors3" struct="TelemetrySensors3" comment="Third set of sensor information"/>
        <Data name="dynamicError" struct="Errors" comment="Dynamic engine errors"/>
        <Data name="stickyError" struct="Errors" comment="Sticky engine errors"/>
        <Data name="wear" struct="EngineWear" comment="Engine wear information"/>
        <Data name="comms" struct="TelemetryComms" comment="Communications error and performance information"/>
        <Data name="sensors4" struct="TelemetrySensors4" comment="Fourth set of sensor information"/>
        <Data name="sdcard" struct="TelemetrySDCard" comment="SD Card telemetry information"/>
        <Data name="extendedoutputs" struct="TelemetryExtendedOutputs" comment="Telemetry for injector3, spark2, and spark3"/>
    </Packet>

    <Documentation comment="---"/>
    <Documentation name="Special Packets for IntelliJect" paragraph="1"/>

    <Packet name="ResetStickyCounter" title="Reset Counter" hidden="true" ID="EFI_PKT_RESET" comment="This packet is used to record the number of times the CPU has reset.">
        <Data name="stickyresetcount" inMemoryType="unsigned16" comment="Non-volatile reset count information. Each time the system boots up, it increments this counter."/>
    </Packet>

    <Packet name="ResetReport" title="Reset Report" ID="EFI_PKT_RESET"
            comment="This packet reports the cause of a reset; it is spontaneously sent each time the EFI resets,  on the first connection from a user. In addition the reset packet can be requested by sending this  packet with zero length. The firmware will handle any unexpected exception or interrupt by immediately performing a software reset. In that case the `exceptionReset` bit will be set, and the exception field will indicate which unhandled interrupt or exception triggered the reset. The register values reported by this packet are only valid for an exception reset. For other reset causes the register values will be zero.

            Resets which are not caused by power are counted in the `errorresetcnt`. If the error counter reaches 20 the software will enter a safe mode in which it does not load any settings from storage. 10 seconds after the system boots up the `errorresetcnt` is zeroed. This makes it possible to recover the system from a reset loop caused by bad settings data.">

        <Enum name="efiExceptionId" title="Exception ID" lookup="true" comment="Enumeration for exceptions or interrupts on the chip. This enumeration will appear in the exception field of a reset report packet if the reset is caused by an exception or unhandled interrupted">
            <Value name="EFI_EXC_NMI" value="2" comment="Non maskable interrupt, Clock Security System"/>
            <Value name="EFI_EXC_HARD_FAULT" comment="All class of fault"/>
            <Value name="EFI_EXC_MEM_MANAGE" comment="Memory management"/>
            <Value name="EFI_EXC_BUS_FAULT" comment="Pre-fetch fault, memory access fault"/>
            <Value name="EFI_EXC_USAGE_FAULT" comment="Undefined instruction or illegal state"/>
            <Value name="EFI_EXC_SV_CALL" value="11" comment="System Service call via SWI instruction"/>
            <Value name="EFI_EXC_DEBUG_MONITOR" comment="Debug Monitor"/>
            <Value name="EFI_EXC_PEND_SV" value="14" comment="Pendable request for system service"/>
            <Value name="EFI_EXC_SYSTICK" comment="System tick timer"/>
            <Value name="EFI_INT_WWDG" comment="Window Watchdog interrupt"/>
            <Value name="EFI_INT_PVD" comment="PVD through EXTI line detection interrupt"/> 
            <Value name="EFI_INT_TAMP_STAMP" comment="Tamper and TimeStamp interrupts through the EXTI line"/> 
            <Value name="EFI_INT_RTC_WKUP" comment="RTC Wakeup interrupt through the EXTI line"/> 
            <Value name="EFI_INT_FLASH" comment="Flash global interrupt"/> 
            <Value name="EFI_INT_RCC" comment="RCC global interrupt"/> 
            <Value name="EFI_INT_EXTI0" comment="EXTI Line0 interrupt"/> 
            <Value name="EFI_INT_EXTI1" comment="EXTI Line1 interrupt"/> 
            <Value name="EFI_INT_EXTI2" comment="EXTI Line2 interrupt"/> 
            <Value name="EFI_INT_EXTI3" comment="EXTI Line3 interrupt"/> 
            <Value name="EFI_INT_EXTI4" comment="EXTI Line4 interrupt"/> 
            <Value name="EFI_INT_DMA1_Stream0" comment="DMA1 Stream0 global interrupt"/> 
            <Value name="EFI_INT_DMA1_Stream1" comment="DMA1 Stream1 global interrupt"/> 
            <Value name="EFI_INT_DMA1_Stream2" comment="DMA1 Stream2 global interrupt"/> 
            <Value name="EFI_INT_DMA1_Stream3" comment="DMA1 Stream3 global interrupt"/> 
            <Value name="EFI_INT_DMA1_Stream4" comment="DMA1 Stream4 global interrupt"/> 
            <Value name="EFI_INT_DMA1_Stream5" comment="DMA1 Stream5 global interrupt"/> 
            <Value name="EFI_INT_DMA1_Stream6" comment="DMA1 Stream6 global interrupt"/> 
            <Value name="EFI_INT_ADC" comment="ADC1 global interrupt"/> 
            <Value name="EFI_INT_CAN1_TX" comment="CAN1 TX interrupt"/> 
            <Value name="EFI_INT_CAN1_RX0" comment="CAN1 RX0 interrupt"/> 
            <Value name="EFI_INT_CAN1_RX1" comment="CAN1 RX1 interrupt"/> 
            <Value name="EFI_INT_CAN1_SCE" comment="CAN1 SCE interrupt"/> 
            <Value name="EFI_INT_EXTI9_5" comment="EXTI Line[9:5] interrupts"/> 
            <Value name="EFI_INT_TIM1_BRK_TIM9" comment="TIM1 Break interrupt and TIM9 global interrupt"/> 
            <Value name="EFI_INT_TIM1_UP_TIM10" comment="TIM1 update interrupt and TIM10 global interrupt"/> 
            <Value name="EFI_INT_TIM_TRG_COM_TIM11" comment="TIM1 Trigger and Commutation interrupts and TIM11 global interrupt"/> 
            <Value name="EFI_INT_TIM1_CC" comment="TIM1 Capture Compare interrupt"/> 
            <Value name="EFI_INT_TIM2" comment="TIM2 global interrupt"/> 
            <Value name="EFI_INT_TIM3" comment="TIM3 global interrupt"/> 
            <Value name="EFI_INT_TIM4" comment="TIM4 global interrupt"/> 
            <Value name="EFI_INT_I2C1_EVT" comment="I2C1 global event interrupt"/> 
            <Value name="EFI_INT_I2C1_ERR" comment="I2C1 global error interrupt"/> 
            <Value name="EFI_INT_I2C2_EVT" comment="I2C2 global event interrupt"/> 
            <Value name="EFI_INT_I2C2_ERR" comment="I2C2 global error interrupt"/> 
            <Value name="EFI_INT_SPI1" comment="SPI1 global interrupt"/> 
            <Value name="EFI_INT_SPI2" comment="SPI2 global interrupt"/> 
            <Value name="EFI_INT_USART1" comment="USART1 global interrupt"/> 
            <Value name="EFI_INT_USART2" comment="USART2 global interrupt"/> 
            <Value name="EFI_INT_USART3" comment="USART3 global interrupt"/> 
            <Value name="EFI_INT_EXTI15_10" comment="EXTI Line[15:10] interrupts"/> 
            <Value name="EFI_INT_EXTI17_RTC_Alarm" comment="EXTI Line 17 interrupt / RTC Alarms (A and B) through EXTI line interrupt"/> 
            <Value name="EFI_INT_EXTI18_OTG_FS_WKUP" comment="EXTI Line 18 interrupt / USB On-The-Go FS Wakeup through EXTI line interrupt"/> 
            <Value name="EFI_INT_TIM8_BRK_TIM12" comment="TIM8 Break interrupt TIM12 global interrupt"/> 
            <Value name="EFI_INT_TIM8_UP_TIM13" comment="TIM8 Update interrupt TIM13 global interrupt"/> 
            <Value name="EFI_INT_TIM8_TRG_COM_TIM14" comment="TIM8 Trigger and Commutation interrupt TIM14 global interrupt"/> 
            <Value name="EFI_INT_TIM8_CC" comment="TIM8 Cap/Com interrupt"/> 
            <Value name="EFI_INT_DMA1_Stream7" comment="DMA1 global interrupt Channel 7"/> 
            <Value name="EFI_INT_FSMC" comment="FSMC global interrupt"/> 
            <Value name="EFI_INT_SDIO" comment="SDIO global interrupt"/> 
            <Value name="EFI_INT_TIM5" comment="TIM5 global interrupt"/> 
            <Value name="EFI_INT_SPI3" comment="SPI3 global interrupt"/> 
            <Value name="EFI_INT_TIM6" value="70" comment="TIM6 global interrupt"/>
            <Value name="EFI_INT_TIM7" comment="TIM7 global interrupt"/> 
            <Value name="EFI_INT_DMA2_Stream0" comment="DMA2 Stream0 global interrupt"/> 
            <Value name="EFI_INT_DMA2_Stream1" comment="DMA2 Stream1 global interrupt"/> 
            <Value name="EFI_INT_DMA2_Stream2" comment="DMA2 Stream2 global interrupt"/> 
            <Value name="EFI_INT_DMA2_Stream3" comment="DMA2 Stream3 global interrupt"/> 
            <Value name="EFI_INT_DMA2_Stream4" comment="DMA2 Stream4 global interrupt"/> 
            <Value name="EFI_INT_DFSDM1_FLT0" comment="SD filter0 global interrupt"/> 
            <Value name="EFI_INT_DFSDM1_FLT1" comment="SD filter1 global interrupt"/> 
            <Value name="EFI_INT_CAN2_TX" comment="CAN2 TX interrupt"/> 
            <Value name="EFI_INT_CAN2_RX0" comment="BXCAN2 RX0 interrupt"/> 
            <Value name="EFI_INT_CAN2_RX1" comment="BXCAN2 RX1 interrupt"/> 
            <Value name="EFI_INT_CAN2_SCE" comment="CAN2 SCE interrupt"/> 
            <Value name="EFI_INT_OTG_FS" comment="USB On The Go FS global interrupt"/> 
            <Value name="EFI_INT_DMA2_Stream5" comment="DMA2 Stream5 global interrupt"/> 
            <Value name="EFI_INT_DMA2_Stream6" comment="DMA2 Stream6 global interrupt"/> 
            <Value name="EFI_INT_DMA2_Stream7" comment="DMA2 Stream7 global interrupt"/> 
            <Value name="EFI_INT_USART6" comment="USART6 global interrupt"/> 
            <Value name="EFI_INT_I2C3_EV" comment="I2C3 event interrupt"/> 
            <Value name="EFI_INT_I2C3_ER" comment="I2C3 error interrupt"/> 
            <Value name="EFI_INT_RNG" value="96" comment="RNG global interrupt"/>
            <Value name="EFI_INT_FPU" comment="FPU global interrupt"/> 
            <Value name="EFI_INT_SPI4" comment="SPI4 global interrupt"/> 
            <Value name="EFI_INT_SPI5" comment="SPI5 global interrupt"/> 
            <Value name="EFI_INT_Quad_SPI" value="108" comment="Quad SPI global interrupt"/>
            <Value name="EFI_INT_I2CFMP1_EV" comment="I2CFMP1 event interrupt"/> 
            <Value name="EFI_INT_I2CFMP1_ER" comment="I2CFMP1 error interrupt"/> 
        </Enum>
      
        <Data name="lowPowerReset" inMemoryType="bitfield1" comment="Reset caused by the low power management"/>
        <Data name="windowWatchdogReset" inMemoryType="bitfield1" comment="Reset caused by the window watchdog"/>
        <Data name="watchdogReset" inMemoryType="bitfield1" comment="Reset caused by the independent watchdog"/>
        <Data name="softwareReset" inMemoryType="bitfield1" comment="Reset caused by software"/>
        <Data name="powerReset" inMemoryType="bitfield1" comment="Reset caused by power on"/>
        <Data name="pinReset" inMemoryType="bitfield1" comment="Reset caused by the reset pin"/>
        <Data name="borReset" inMemoryType="bitfield1" comment="Brown out reset"/>
        <Data name="exceptionReset" inMemoryType="bitfield1" comment="Reset caused by unhandled exception or interrupt"/>
        <Data name="exception" inMemoryType="unsigned8" comment="The number of the interrupt or exception which caused this reset, valid only if `exceptionReset` is set, otherwise zero."/>
        <Data name="first" inMemoryType="bitfield1" comment="If set, this is the first report generated since the system reset. Subsequent requests for the reset report will have this bit clear."/>
        <Data name="safeModeActive" inMemoryType="bitfield1" comment="If set the system booted in safe mode because `errorresetcnt` was too large. No settings data were loaded from non-volatile storage in this mode. The only way to exit safe mode is to reset the system."/>
        <Data name="quickRestartActive" inMemoryType="bitfield1" comment="If set the system booted in quick restart mode because the engine was running when the reset occurred."/>
        <Data name="specialWatchdogReset" inMemoryType="bitfield1" comment="Reset caused by special watchdog handling. This is an exception that fires before the true watchdog in an attempt to learn the program counter of the stuck code."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield4"/>
        <Data name="count" inMemoryType="unsigned8" comment="Volatile reset count information. Each time the system boots up, it increments this counter. If the system resets by losing power long enough to clear the RAM then this counter will reset to zero. After the counter reaches 255 it will roll over to zero."/>
        <Data name="programCounter" inMemoryType="unsigned32" comment="The program counter of the instruction that triggered the exception."/>
        <Data name="linkRegister" inMemoryType="unsigned32" comment="The link register at the time of the exception."/>
        <Data name="xpsr" inMemoryType="unsigned32" comment="The program status register at the time of the exception."/>
        <Data name="fpscr" inMemoryType="unsigned32" comment="The floating point status and control register at the time of the exception."/>
        <Data name="cfsr" inMemoryType="unsigned32" comment="The configurable fault status register at the time of the exception."/>
        <Data name="mmfar" inMemoryType="unsigned32" default="0" comment="The memory management fault address register at the time of the exception."/>
        <Data name="bfar" inMemoryType="unsigned32" default="0" comment="The bus fault address register at the time of the exception."/>
        <Data name="errorresetcnt" inMemoryType="unsigned8" default="0" comment="The error reset count is incremented once for each time the system resets due to an error which is not power related. If the error counter reaches 20 the software will enter a safe mode in which it does not load any settings from storage. 10 seconds after the system boots up the `errorresetcnt` is zeroed."/>
        <Data name="stickyresetcount" inMemoryType="unsigned16" default="0" comment="Non-volatile reset count information. Each time the system boots up, it increments this counter."/>

    </Packet>

    <Packet name="Nack" title="Not Acknowledge Packet" ID="EFI_PKT_NACK"
        comment="This packet is sent by the EFI to indicate a not-acknowledge response. The nack always occurs in reponse to a packet from the user. There are six different nack cases: 1) The input packet was not recognized. 2) The input packet attempted to change locked configuration data, 3) The input packet attempted to read hidden configuration data, 4) The input packet attempted a command that cannot be performed while the engine is running, or 5) The input packet was `EFI_PKT_REQUEST` but one of the request bits was reserved, or 6) The input packet required the system be enabled when it was disabled, or vice versa.">
        <Enum name="efiNackCause" title="Causes of a Nack" comment="Enumeration describing the cause of the nack">
            <Value name="nackPktNotRecognized" comment="Nack due to unrecognized input packet."/>
            <Value name="nackDataAreLocked" comment="Nack due to attempt to change locked data."/>
            <Value name="nackDataAreHidden" comment="Nack due to attempt to read hidden configuration data."/>
            <Value name="nackRunningIncorrect" comment="Nack due to engine running when it needs to be off, or vice versa."/>
            <Value name="nackReqBitNotRecognized" comment="Nack due to use of a reserved bit in the request packet."/>
            <Value name="nackLogIsFull" comment="Nack due to log being full."/>
            <Value name="nackEnableIncorrect" comment="Nack due to system being disabled when it needs to be enabled, or vice versa."/>
        </Enum>
        <Data name="type" inMemoryType="unsigned8" comment="The type of the packet that triggered the NACK response."/>
        <Data name="cause" enum="efiNackCause" encodedType="bitfield3" comment="The reason for the nack response."/>
        <Data name="index" inMemoryType="unsigned8" encodedType="bitfield5" comment="The index information from the first data byte of the packet that triggered the NACK response. This is only relevant for those packets that have indices."/>
        <Data name="requestbit" inMemoryType="unsigned8" default="0" comment="If the cause of the nack was `nackReqBitNotRecognized` this field gives the bit number, from 95 (most significant) to 0 (least), of the request bit that was not understood."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2" default="0"/>
        <Data name="index" inMemoryType="override" encodedType="bitfield6" default="0" comment="The index information from the first data byte of the packet that triggered the NACK response. This is only relevant for those packets that have indices."/>

    </Packet>

    <Packet name="OscilloscopeSetup" title="Oscilloscope setup packet" ID="EFI_PKT_OSCILLOSCOPE_SETUP" comment="This packet is used to configure and enable the high speed oscilloscope. Triggering scope mode when a previous scope capture is underway will cause the previous capture to be discarded. If you ask for continuous scope output, but lack the neccessary communications bandwidth, the scope output will be intermittent. A single scope capture may take multiple packets to completely report. Send this packet with zero length to request the current oscilloscope setup.">

        <Enum name="efiScopeEnum" title="EFI oscilloscope signal List" lookupTitle="true" comment="Enumeration for scope signals in the EFI. The first signals match exactly the enumerations of the EFI sensors.">
            
            <Value name="EFI_SCOPE_FIRSTANALOG" hidden="true" ignoreLookup="true" comment="First analog scope signal number"/>
            <Value name="EFI_SCOPE_VOLT" value="EFI_SCOPE_FIRSTANALOG" title="Input Voltage" comment="Input voltage sensor, units of Volts"/>
            <Value name="EFI_SCOPE_MAT" title="MAT" comment="Manifold air temperature sensor, units of Celsius"/>
            <Value name="EFI_SCOPE_CHT1" title="CHT1" comment="First cylinder head temperature sensor, units of Celsius"/>
            <Value name="EFI_SCOPE_CHT2" title="CHT2" comment="Second cylinder head temperature sensor, units of Celsius"/>
            <Value name="EFI_SCOPE_MAP" title="MAP" comment="Manifold pressure sensor, units of kilo-Pascals"/>
            <Value name="EFI_SCOPE_FUELP" title="Fuel pressure" comment="Fuel pressure sensor, units of kilo-Pascals"/>
            <Value name="EFI_SCOPE_ANALOGTPS" title="Analog TPS" comment="Analog throttle sensor, units of percent"/>
            <Value name="EFI_SCOPE_CPUTEMP" title="CPU Temp" comment="Temperature of the CPU, units of Celsius"/>
            <Value name="EFI_SCOPE_SPARETEMP" title="Spare Temp" comment="Spare temperature sensor, units of Celsius"/>
            <Value name="EFI_SCOPE_RESERVED2" title="Reserved"/>
            <Value name="EFI_SCOPE_RESERVED3" title="Reserved"/>
            <Value name="EFI_SCOPE_CURRENT" title="Current" comment="Input current sensor, units of Amps"/>
            <Value name="EFI_SCOPE_12VOLT" title="12 Volts" comment="12 Volt rail voltage sensor, units of Volts"/>
            <Value name="EFI_SCOPE_12CURRENT" title="12 Current" comment="12 Volt rail current sensor, units of Amps"/>
            <Value name="EFI_SCOPE_ANALOGBARO" title="Barometer" comment="Analog barometric pressure sensor, units of kilo-Pascals"/>
            <Value name="EFI_SCOPE_RESERVED4" title="Reserved"/>
            <Value name="EFI_SCOPE_LASTANALOG" hidden="true" ignoreLookup="true" value="EFI_SCOPE_RESERVED4" comment="Last analog scope signal number"/>
            <Value name="EFI_SCOPE_FIRSTDIGITAL" hidden="true" ignoreLookup="true" comment="First digital scope signal number"/>
            <Value name="EFI_SCOPE_IOENABLE"  value="EFI_SCOPE_FIRSTDIGITAL" title="IO enable" comment="IO enable scope signal"/>
            <Value name="EFI_SCOPE_CRANKSENSE1" title="Crank sense 1" comment="First crank sense scope signal"/>
            <Value name="EFI_SCOPE_CRANKSENSE2" title="Crank sense 2" comment="Second crank sense scope signal"/>
            <Value name="EFI_SCOPE_THROTTLEOUT" title="Throttle out" comment="Throttle PWM output scope signal"/>
            <Value name="EFI_SCOPE_THROTTLEIN" title="Throttle in" comment="Throttle PWM input scope signal"/>
            <Value name="EFI_SCOPE_COOLINGOUT" title="Cooling out" comment="Cooling PWM output scope signal"/>
            <Value name="EFI_SCOPE_EDGEERROR" title="Edge error" comment="An output edge error was detected"/>
            <Value name="EFI_SCOPE_SPARK1" title="Spark 1" comment="First spark output scope signal"/>
            <Value name="EFI_SCOPE_SPARK2" title="Spark 2" comment="Second spark output scope signal"/>
            <Value name="EFI_SCOPE_SPARK3" title="Spark 3" comment="Third spark output scope signal"/>
            <Value name="EFI_SCOPE_INJECTOR1" title="Injector 1" comment="First injector output scope signal"/>
            <Value name="EFI_SCOPE_INJECTOR2" title="Injector 2" comment="Second injector output scope signal"/>
            <Value name="EFI_SCOPE_INJECTOR3" title="Injector 3" comment="Third injector output scope signal"/>
            <Value name="EFI_SCOPE_CRANKERROR1" title="Crank 1 error" comment="Error flag on first crank sense signal"/>
            <Value name="EFI_SCOPE_CRANKERROR2" title="Crank 2 error" comment="Error flag on second crank sense signal"/>
            <Value name="EFI_SCOPE_ASYNCSAMPLE" title="Asynchronous" comment="Flag on whether this sample was asynchronous (bit is set) or synchronous (bit is clear)"/>
            <Value name="EFI_SCOPE_LASTDIGITAL" hidden="true" ignoreLookup="true" value="EFI_SCOPE_ASYNCSAMPLE" comment="Last digital scope signal number"/>
            <Value name="NUM_EFI_SCOPE_SIGNALS" hidden="true" ignoreLookup="true"/>
        </Enum>

        <Data name="enable" inMemoryType="bitfield1" comment="Set to enable the oscilloscope, for packets going to the EFI. For packets from the EFI this reports the running status of the scope."/>
        <Data name="single" inMemoryType="bitfield1" comment="Set for a single oscilloscope reporting window. If this is set the oscilloscope will automatically disable after a single capture."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield8"/>
        <Data name="timewindow" inMemoryType="bitfield22" comment="Time window the scope will report in microseconds."/>
        <Data name="reserved" inMemoryType="null" encodedType="unsigned8"/>
        <Data name="triggerenable" inMemoryType="bitfield1" comment="Set to enable triggering, if clear then the scope is always triggered (i.e. always generating data)."/>
        <Data name="triggerfalling" inMemoryType="bitfield1" comment="Set to trigger on the falling edge, else the trigger is on the rising edge."/>
        <Data name="triggerchannel" enum="efiScopeEnum" encodedType="bitfield6" comment="Scope channel used to trigger oscilloscope output, if `triggerenable` is set."/>
        <Data name="triggerlevel" inMemoryType="unsigned16" comment="Level of the trigger channel that causes an oscilloscope trigger. For analog sensor signals this in raw ADC units, with 0 the lowest value from the ADC and 65535 the largest value from the ADC. For digital signals this is either 0 or 1."/>
        <Data name="channels" inMemoryType="unsigned32" comment="A bitfield flag indicating which channels should be captured for the scope. The channel numbers follow `efiScopeEnum` enumeration, with channel zero being the least significant bit. Digital channels (`EFI_SCOPE_IOENABLE` and higher) are always reported in the data packet, but will not generate data packets unless they are set in this bitfield."/>
    </Packet>
    
    <Packet name="OscilloscopeData" title="Oscilloscope data packet" ID="EFI_PKT_OSCILLOSCOPE_DATA" comment="This packet is used to report the oscilliscope data. If the scope is setup for continuous output, but the communications hardware lacks the neccessary bandwidth, the scope output will be intermittent. A single scope capture will usually take multiple packets to completely report; however the exact number of packets is not known until the scope capture is complete. The EFI will begin sending scope data as soon as possible, and the transfer is complete when the `lastPacket` flag is set.

    The oscilloscope data packet can contain multiple samples of data. Since the number of signals in each sample depends on the oscilloscope configuration the data are encoded as a repeating array of 16-bit words. The first word is always the time offset, which gives the time of the sample in microseconds, relative to the `reftime` of the packet. The second word of the sample is always the digital sample word, with the least significant bit corresponding to the `EFI_SCOPE_IOENABLE` digital channel. The remaining words in the sample provide the analog scope signals; the number of analog signals are given by `numAnalogPerSample`, which will equal the number of analog channels that were selected in the oscilloscope configuration packet. The total number of words in the packet will always be a multiple of `2 + numAnalogPerSample`. The analog signals are transmitted in their raw 16-bit ADC form. You must use the sensor configurations to convert the sensors to engineering units data.">

        <Enum name="efiScopeDataWords" title="EFI oscilloscope data word list" comment="Enumeration for data words.">
            <Value name="EFI_SCOPE_WORD_TIME" comment="The first word in a series is the time offset in microseconds"/>
            <Value name="EFI_SCOPE_WORD_DIGITALS" comment="The second word in a series is the digital sample field"/>
            <Value name="EFI_SCOPE_WORD_FIRSTANALOG" comment="The third word in a series is the first analog sample field"/>
            <Value name="EFI_SCOPE_MAX_WORDS" value="500" comment="A maximum of 500 words in a packet"/>
        </Enum>
        
        <Data name="lastPacket" inMemoryType="bitfield1" comment="If set this packet is the last packet in a series of scope packets that report a single scope window of data."/>
        <Data name="triggerTimeIncluded" inMemoryType="bitfield1" comment="If set this packet contains the time reference of the triggering event."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="packetCount" inMemoryType="bitfield12" comment="The number of this packet in the series of scope packets that report a single scope window of data. This value will be zero on the first scope packet."/>
        <Data name="numAnalogPerSample" inMemoryType="bitfield5" comment="The number of analog channels that are included per sample in this packet."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2"/>
        <Data name="numWords" inMemoryType="bitfield9" comment="Number of words in this packet. The number of samples in the packet is equal to `numWords / (2 + numAnalogPerSample)`"/>
        <Data name="refTime" inMemoryType="unsigned64" encodedType="unsigned48" comment="Time in microseconds since the system booted up. This is the reference time used for subsequent samples in the packet."/>
        <Data name="triggerTime" inMemoryType="unsigned64" encodedType="unsigned48" dependsOn="triggerTimeIncluded" comment="Time in microseconds since the system booted up when the trigger event occurred."/>
        <Data name="words" inMemoryType="unsigned16" array="EFI_SCOPE_MAX_WORDS" variableArray="numWords" comment="The words of the samples. The interpretation of the sample words depends on the oscilloscope configuration."/>    
    </Packet>

    <Packet name="Debug" ID="EFI_PKT_DEBUG" parameterInterface="true" comment="This packet gives data used for debugging. The interpretation of this packet is variable.">
        <Data name="time" inMemoryType="unsigned32" comment="Time in microseconds of the debug output"/>
        <Data name="details" inMemoryType="unsigned8" array="12" comment="12 bytes of data to use as the debugger sees fit"/>
        <Data name="comment" inMemoryType="string" array="512" comment="Human readable debug string"/>
    </Packet>

    <Packet name="TestMode" ID="EFI_PKT_TESTMODE" comment="The test mode packet is used to engage special features for testing software and hardware. In order to engage test mode the EFI must be unlocked, and the engine must not be running. If the engine starts running while test mode is active (as indicated by crank sense detection) the test mode will be automatically canceled. Test mode can also be canceled by this packet, by locking the EFI configuration, or by timeout. When test mode is active this packet will be reported at the slow telemetry rate to indicate the test mode status.
        
        The test mode status is always visible in the telemetry errors packet. In addition you can send this packet with zero length to request the current test mode status.">
        <Data name="enabled" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable test mode. For report packets this is the test mode status."/>
        <Data name="enableThrottleClosedCalibration" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable automatic calibration of the throttle `closedPWMout` value."/>
        <Data name="enableThrottleOpenCalibration" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable automatic calibration of the throttle `openPWMout` value."/>
        <Data name="skipCrankSense1" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to skip the processing of one event cycle for crank sense 1."/>
        <Data name="skipCrankSense2" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to skip the processing of one event cycle for crank sense 2."/>
        <Data name="addToothCrankSense1" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to add an extraneous sensed tooth for crank sense 1."/>
        <Data name="addToothCrankSense2" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to add an extraneous sensed tooth for crank sense 1."/>
        <Data name="timeout" inMemoryType="unsigned16" encodedType="bitfield9" comment="Test mode timeout in seconds. For report packets this is the amount of time remaining in the test. If the test is user storage this is percent remaining."/>
        <Data name="testCrankSenseNormal" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to simulate crank sense events in the normal direction."/>
        <Data name="testInjector1" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set for injector1 test"/>
        <Data name="testInjector2" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set for injector2 test"/>
        <Data name="testSpark1" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set for spark1 test"/>
        <Data name="testSpark2" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set for spark2 test"/>
        <Data name="testFuelpump" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to drive the fuel pump at a specific duty cycle"/>
        <Data name="testFuelflow" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to control the injector duty cycle to achieve a fuel pressure. This should be combined with testInjector1 or testInjector2 to specify which injector is used to regulate the fuel pressure."/>
        <Data name="testCrankSenseReverse" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to simulate crank sense events in the reverse direction."/>
        <Data name="missFire1" inMemoryType="unsigned8" encodedType="bitfield2" comment="Number of skipped outputs for spark1; 0 - 3."/>
        <Data name="missFire2" inMemoryType="unsigned8" encodedType="bitfield2" comment="Number of skipped outputs for spark2; 0 - 3."/>
        <Data name="enableCowlFlap2ClosedCalibration" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable automatic calibration of the cowl flap 2 `closedPWM` value."/>
        <Data name="enableCowlFlap2OpenCalibration" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable automatic calibration of the cowl flap 2 `openPWM` value."/>
        <Data name="enableCowlFlap1ClosedCalibration" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable automatic calibration of the cowl flap 1 `closedPWM` value."/>
        <Data name="enableCowlFlap1OpenCalibration" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable automatic calibration of the cowl flap 1 `openPWM` value."/>
        <Data name="dutycycle" inMemoryType="float" encodedType="unsigned16" max="100" comment="For injector, spark, and fuel pump tests this is duty cycle in percentage to apply to the injector output, spark output, or fuel pump output"/>
        <Data name="speed" inMemoryType="float" encodedType="unsigned16" scaler="4" comment="The frequency, in events per minute, at which the test should be performed. This does not apply to the fuel pump test."/>
        <Data name="fuelflowProGain" inMemoryType="float" encodedType="float16" comment="Proportional feedback gain for fuel flow test from kPa of fuel pressure error to percentage of injector duty cycle"/>
        <Data name="fuelflowIntGain" inMemoryType="float" encodedType="float16" comment="Integral feedback gain for fuel flow test from integral of kPa of fuel pressure error to percentage of injector duty cycle"/>
        <Data name="currentThreshold" inMemoryType="float32" encodedType="unsigned8" default="0.1" scaler="200" comment="The current rise used to indicate that a hard stop was discovered, used with `enableThrottleClosedCalibration`, `enableThrottleOpenCalibration`, `enableCowlFlapClosedCalibration`, and `enableCowlFlapOpenCalibration`."/>
        <Data name="actualClosedStop" inMemoryType="float32" encodedType="unsigned8" default="0" min="-30" scaler="4" comment="The actual position, in percent, of the closed hard stop used with `enableThrottleClosedCalibration` or `enableCowlFlapClosedCalibration`."/>
        <Data name="actualOpenStop" inMemoryType="float32" encodedType="unsigned8" default="100" min="70" scaler="4" comment="The actual position, in percent, of the open hard stop used with `enableThrottleOpenCalibration` or `enableCowlFlapOpenCalibration`."/>
        <Data name="testInjector3" inMemoryType="unsigned8" encodedType="bitfield1" default="0" comment="Set for injector3 test"/>
        <Data name="testSpark3" inMemoryType="unsigned8" encodedType="bitfield1" default="0" comment="Set for spark3 test"/>
        <Data name="missFire3" inMemoryType="unsigned8" encodedType="bitfield2" default="0" comment="Number of skipped outputs for spark3; 0 - 3."/>
        <Data name="testUserStorage" inMemoryType="unsigned8" encodedType="bitfield1" default="0" comment="Set to enable test of user storage space. This will exercise the entire EEPROM. Do not disonnect from power until the test is complete, otherwise some data in user stroage may be lost. This test cannot be done simultaneously with other tests."/>
        <Data name="reserved" inMemoryType="null" default="0" encodedType="bitfield3"/>
    </Packet>

    <Packet name="RequestCrankSenseTiming" ID="EFI_PKT_CRANKSENSETIMING" parameterInterface="true" comment="Request crank sense timing packets. To request the crank sense timing set either `onesample` or `continuous`. To stop the crank sense timing packets clear `continuous`">
        <Data name="onesample" inMemoryType="bitfield1" comment="Set this bit to request one capture of data."/>
        <Data name="continuous" inMemoryType="bitfield1" comment="Set this bit to request crank sense timing packets be sent continuously."/>
        <Data name="onsynclost" inMemoryType="bitfield1" comment="Set this bit to downlink the timing when synchronization is lost."/>
        <Data name="sense2" inMemoryType="bitfield1" comment="Set this bit to request crank sense timing for sense 2, otherwise the data are requested for sense 1."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield3" comment="Reserved bits for future expansion."/>
        <Data name="numIntervals" inMemoryType="unsigned16" encodedType="bitfield9" comment="The requested number of sense intervals. For crank wheels IntelliJect will adjust this to be an even multiple of the number of physical teeth (totalCount - bigGapCount - smallGapCount). Maximum value is 500."/>
    </Packet>

    <Packet name="CrankSenseTiming" ID="EFI_PKT_CRANKSENSETIMING" comment="Details of the crank sense timing. To receive this packet you must first send the `RequestCrankSenseTiming` packet. The crank sense timing details simply give the time intervals of crank sense events (active edges). This is most useful for crank wheels, but can be used for once-per-rev sensors.">
        <Enum name="CrankSenseTimingConstants" comment="Enumerations for the crank sense timing packet">
            <Value name="maxCrankSenseIntervals" value="500" comment="Maximum sense intervals"/>
        </Enum>

        <Data name="onesample" inMemoryType="unsigned8" encodedType="bitfield1" comment="If set a single crank sense timing packet was sent."/>
        <Data name="continuous" inMemoryType="unsigned8" encodedType="bitfield1" comment="If set crank sense timing packets will be sent continuously."/>
        <Data name="onsynclost" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set this bit to downlink the timing when synchronization is lost."/>
        <Data name="sense2" inMemoryType="unsigned8" encodedType="bitfield1" comment="If set this timing data comes from crank sense 2, otherwise it is from crank sense 1."/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield2" comment="Reserved bits for future expansion."/>
        <Data name="wheelenabled" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if this timing data are for a crank wheel, else it is for a once per rev sensor."/>
        <Data name="numIntervals" inMemoryType="unsigned16" encodedType="bitfield9" comment="The number of sense intervals in this packet. For crank wheels this will be a multiple of the number of physical teeth (totalCount - bigGapCount - smallGapCount). Maximum value is 500."/>
        <Data name="crankOffset" inMemoryType="float32" encodedType="unsigned16" max="360" comment="Angle of the crank sense in degrees of crank rotation after TDC, in the current crank rotation direction. For crank wheels this is the angle of the first tooth after the big gap."/>
        <Data name="totalCount" inMemoryType="unsigned8" dependson="wheelenabled" comment="The number of teeth on the crank wheel plus the missing teeth. This is the full count, as though no synchronization teeth were removed."/>
        <Data name="bigGapCount" inMemoryType="unsigned8" dependson="wheelenabled" comment="The number of teeth missing in the big gap of the crank wheel. The end of the big gap is the crank angle synchronization point. There must always be a non-zero big gap count."/>
        <Data name="smallGapCount" inMemoryType="unsigned8" dependson="wheelenabled" comment="The number of teeth missing in the small gap of the crank wheel. The small gap count can be zero, in which case there is no small gap, and no intra-gap."/>
        <Data name="intraGapCount" inMemoryType="unsigned8" dependson="wheelenabled" comment="The number of teeth between the big gap and the small gap for the current direction of rotation. Zero if there is no small gap."/>
        <Data name="time" inMemoryType="unsigned32" comment="Time in milliseconds since the system booted up. This is the reference time for subsequent intervals."/>
        <Data name="intervals" inMemoryType="unsigned16" array="maxCrankSenseIntervals" variableArray="numIntervals" comment="The time difference of each sense event from the previous event in microseconds."/>
    </Packet>

    <Structure name="InterruptDetail" comment="Details about the timing of an interrupt">
        <Data name="count" inMemoryType="unsigned16" comment="Number of times this interrupt fired during the reporting period"/>
        <Data name="totaltime" inMemoryType="unsigned16" comment="Total amount of time used by this interrupt during the reporting period"/>
        <Data name="preemptcount" inMemoryType="unsigned8" comment="Number of times this interrupt was preempted"/>
        <Data name="maxtime" inMemoryType="unsigned8" comment="Maximum amount of time in microseconds this interrupt took during this reporting period"/>
    </Structure>

    <Packet name="InterruptDetails" ID="EFI_PKT_INTERRUPTDETAILS" hidden="true" comment="This packet gives data used for interrupt debugging. This packet is sent at the slow telemetry rate, but only if enabled. To enable sending of this packet send this packet with one non-zero byte to the EFI. To stop sending of this packet send this packet with one zero byte.">

        <Enum name="interruptIndices" title="IntelliJect interrupt indices" lookupTitle="true" comment="Enumeration for the IntelliJect interrupts">
            <Value name="systickInt" title="Systick"/>
            <Value name="timer4Int" title="Timer 4"/>
            <Value name="timer1Int" title="Timer 1"/>
            <Value name="timer2Int" title="Timer 2"/>
            <Value name="timer3Int" title="Timer 3"/>
            <Value name="timer5Int" title="Timer 5"/>
            <Value name="ext01Int" title="Ext0 and Ext1"/>
            <Value name="timer9Int" title="Timer 9"/>
            <Value name="uartInt" title="UART"/>
            <Value name="i2ceventInt" title="I2C event"/>
            <Value name="i2cerrorInt" title="I2C error"/>
            <Value name="canrx0Int" title="CAN rx0"/>
            <Value name="canrx1Int" title="CAN rx1"/>
            <Value name="cantxInt" title="CAN tx"/>
            <Value name="sdioInt" title="SDIO"/>
            <Value name="fpuInt" title="FPU"/>
            <Value name="numInterrupts"/>
        </Enum>

        <Data name="intdetails" struct="InterruptDetail" array="numInterrupts" comment="Interrupt details for all the interrupt sources"/>

    </Packet>

    <Packet name="Bootloader" title="Boot Loader Packet" ID="EFI_PKT_BOOTLOADER" comment="Packet for bootloader interactions. The bootloader is a separate application within the EFI firmware load; and only the bootloader will send, or respond to, this packet. The bootloader uses fixed communications configurations. On serial the bit rate is always 57600 bits per second. On CAN the bit rate is always 1Mbit, the identifier is always 11-bits, the input ID is always 0x400, and the output ID is always 0x401. Only one device on the CAN bus can be in bootloader mode at a time.

        When the bootloader is running it will output this packet on a regular basis as a heartbeat. In order to program the firmware you must watch for the bootloader packet and use the serial number that it contains in any packet sent back to the bootloader. In order to start the bootloader you use the [reset command](#EFI_PKT_RESET) packet.">

        <Enum name="bootloadercmds" title="Commands understood by the bootloader" comment="Enumeration for the bootloader commands">
            <Value name="btldHeartBeat" comment="Heart beat packet from the bootloader, sent once per second"/>
            <Value name="btldEraseCmd" comment="Erase command to the bootloader"/>
            <Value name="btldEraseAck" comment="Erase acknowledgement from the bootloader"/>
            <Value name="btldEraseNack" comment="Erase failure notification from the bootloader"/>
            <Value name="btldProgramCmd" comment="Program command to the bootloader"/>
            <Value name="btldProgramAck" comment="Program acknowledgement from the bootloader"/>
            <Value name="btldProgramNack" comment="Program failure notification from the bootloader"/>
            <Value name="btldReset" comment="Command to reset to the main application"/>
        </Enum>

        <Enum name="bootloadercomms" title="Bootloader communications settings" comment="Settings used for bootloader communication">
            <Value name="btldUartBaud" value="57600" comment="Bit rate used for the uart under the bootloader"/>
            <Value name="btldCanBaud" value="EFI_CAN_1M" comment="Bit rate used for the CAN under the bootloader"/>
            <Value name="btldCanInputId" value="0x400" comment="Identifier used for CAN input under the bootloader"/>
            <Value name="btldCanOutputId" value="0x401" comment="Identifier used for CAN output under the bootloader"/>
        </Enum>

        <Data name="serialnumber" inMemoryType="unsigned32" comment="32-bit serial number of the EFI. When the bootloader packet comes from the EFI this contains the serial number of the EFI. When the bootloader packet goes to the EFI this must have the correct EFI serial number in order for this packet to be obeyed."/>
        <Data name="startaddress" inMemoryType="unsigned32" comment="Starting address for this packet. This is used for erase as well as program. For the heartbeat packet this will be address `0x0801001C`, and the datsize will be at least 16 bytes."/>
        <Data name="datasize" inMemoryType="unsigned32" comment="Data size for this packet. This is used for erase as well as program. For the program packet this datasize cannot be more than 256. For the program nack packet this indicates the first byte which failed to program."/>
        <Data name="version" inMemoryType="unsigned8" comment="Version of the bootloader from 0 to 255"/>
        <Data name="hasprogramdata" inMemoryType="bitfield1" comment="Set if this packet includes program data"/>
        <Data name="reserved" inMemoryType="null" encodedType="bitfield3" comment="Reserved bits for future expansion"/>
        <Data name="command" enum="bootloadercmds" encodedType="bitfield4" comment="The purpose of this bootloader packet"/>
        <Data name="programdata" inMemoryType="unsigned8" array="256" variableArray="datasize" dependsOn="hasprogramdata" comment="Program data, starting at startaddress"/>
    </Packet>

    <Packet name="SDCardBlockData" hidden="true" ID="EFI_PKT_SDBLOCKDATA" parameterInterface="true" comment="This packet is at the beginning of every valid block of 512 bytes (except the journal) of an SD card. This packet cannot be sent to or from the EFI.">
        <Data name="reserved" inMemoryType="null" encodedType="unsigned16"/>
        <Data name="record" inMemoryType="unsigned16" comment="The record number identifies the recording. Consecutive packets from the same recording will have the same record number."/>
        <Data name="sequence" inMemoryType="unsigned32" comment="SD sequence number, starts at 0 and increasing monotonically. If successive sequence numbers go down the boundary represents a wrap point."/>
    </Packet>
        
    <Packet name="SensorAutoOffsets" hidden="true" ID="EFI_PKT_SENSORAUTOOFFSET" comment="This packet stores the sensor offset values for sensors that are auto-corrected. It cannot be sent to or from the EFI">
        <Data name="autooffsets" array="NUM_EFI_SENSORS" inMemoryType="float32" encodedType="signed16" max="1" comment="Sensor offset value for those sensors which are auto-corrected. This value will be zero for sensors that are not auto-corrected."/>
        <Data name="reserved" array="4" inMemoryType="null" encodedType="unsigned16"/>
    </Packet>

    <Packet name="QuickRestart" hidden="true" ID="EFI_PKT_QUICKRESTART" comment="This packet provides the minimum amount of data needed to fire the spark and run the injectors, before the entire EFI system and sensors are up and running. This packet is never sent or received; it exists only in backup RAM onboard the EFI.">
        
        <Data name="enablequickrestart" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set to enable quick start response"/>
        <Data name="ioEnable" inMemoryType="unsigned8" encodedType="bitfield1" comment="Global enable based on physical input"/>
        <Data name="userEnable" inMemoryType="unsigned8" encodedType="bitfield1" comment="User global enable."/>
        <Data name="spark1UserEnable" inMemoryType="unsigned8" encodedType="bitfield1" comment="User enable for spark1."/>
        <Data name="spark2UserEnable" inMemoryType="unsigned8" encodedType="bitfield1" comment="User enable for spark2."/>
        <Data name="spark3UserEnable" inMemoryType="unsigned8" encodedType="bitfield1" comment="User enable for spark3."/>
        <Data name="userThrottleCmd" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if a user throttle command is active."/>
        <Data name="userRPMCmd" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if a user rpm command is active."/>

        <Data name="throttlecmd" inMemoryType="float32" encodedType="unsigned8" scaler="2" comment="The user commanded throttle in percent"/>
        <Data name="rpmcmd" inMemoryType="float32" encodedType="unsigned16" scaler="2" comment="Engine speed command in revolutions per minute"/>

        <Data name="ignActiveHigh" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if ignition is active high"/>
        <Data name="spark3ConfigEnabled" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if spark 3 is configured enabled"/>
        <Data name="injector3ConfigEnabled" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if injector 3 is configured enabled"/>
        <Data name="direction1" enum="efiCrankDirection" encodedType="bitfield2" comment="Direction information for crank 1"/>
        <Data name="direction2" enum="efiCrankDirection" encodedType="bitfield2" comment="Direction information for crank 2"/>
        <Data name="pwmOut" inMemoryType="unsigned16" encodedType="bitfield9" comment="Throttle pwm output time in 4 microseconds"/>

        <Data name="crankPeriod" inMemoryType="unsigned32" encodedType="unsigned16" comment="Crank period in 4 microseconds"/>
        <Data name="spark1delay" inMemoryType="unsigned32" encodedType="unsigned16" comment="Time delay in 4 microseconds from the sense ISR to output of spark1"/>
        <Data name="spark2delay" inMemoryType="unsigned32" encodedType="unsigned16" comment="Time delay in 4 microseconds from the sense ISR to output of spark2"/>
        <Data name="spark3delay" inMemoryType="unsigned32" encodedType="unsigned16" comment="Time delay in 4 microseconds from the sense ISR to output of spark3"/>
        <Data name="injector1delay" inMemoryType="unsigned32" encodedType="unsigned16" comment="Time delay in 4 microseconds from the sense ISR to output of injector1"/>
        <Data name="injector2delay" inMemoryType="unsigned32" encodedType="unsigned16" comment="Time delay in 4 microseconds from the sense ISR to output of injector2"/>
        <Data name="injector3delay" inMemoryType="unsigned32" encodedType="unsigned16" comment="Time delay in 4 microseconds from the sense ISR to output of injector3"/>
        <Data name="injector1period" inMemoryType="unsigned32" encodedType="unsigned16" comment="Injection time in 4 microseconds for injector1"/>
        <Data name="injector2period" inMemoryType="unsigned32" encodedType="unsigned16" comment="Injection time in 4 microseconds for injector2"/>
        <Data name="injector3period" inMemoryType="unsigned32" encodedType="unsigned16" comment="Injection time in 4 microseconds for injector3"/>
        <Data name="sparkPeriod" inMemoryType="unsigned32" encodedType="unsigned16" comment="Spark period in 4 microseconds"/>

        <Data name="spark1usesense1" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if spark 1 is being triggered by sense 1"/>
        <Data name="spark2usesense1" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if spark 2 is being triggered by sense 1"/>
        <Data name="spark3usesense1" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if spark 3 is being triggered by sense 1"/>
        <Data name="injector1usesense1" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if injector 1 is being triggered by sense 1"/>
        <Data name="injector2usesense1" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if injector 2 is being triggered by sense 1"/>
        <Data name="injector3usesense1" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if injector 3 is being triggered by sense 1"/>
        <Data name="spark1usesense2" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if spark 1 is being triggered by sense 2"/>
        <Data name="spark2usesense2" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if spark 2 is being triggered by sense 2"/>

        <Data name="spark3usesense2" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if spark 3 is being triggered by sense 2"/>
        <Data name="injector1usesense2" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if injector 1 is being triggered by sense 2"/>
        <Data name="injector2usesense2" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if injector 2 is being triggered by sense 2"/>
        <Data name="injector3usesense2" inMemoryType="unsigned8" encodedType="bitfield1" comment="Set if injector 3 is being triggered by sense 2"/>        
        <Data name="wheel1SyncStatus" enum="efiCrankWheelSyncStatus" encodedType="bitfield2" comment="Synchronization status for crank wheel 1 "/>
        <Data name="wheel2SyncStatus" enum="efiCrankWheelSyncStatus" encodedType="bitfield2" comment="Synchronization status for crank wheel 2"/>
        <Data name="crankSense1" struct="CrankSense" comment="Details of the crank sense 1 configuration"/>
        <Data name="crankSense2" struct="CrankSense" comment="Details of the crank sense 2 configuration"/>

        <Data name="spark1sense1tooth" inMemoryType="unsigned8" encodedType="bitfield6" comment="The crank wheel tooth, on crank sense 1, that schedules spark1"/>
        <Data name="spark2sense1tooth" inMemoryType="unsigned8" encodedType="bitfield6" comment="The crank wheel tooth, on crank sense 1, that schedules spark2"/>
        <Data name="spark3sense1tooth" inMemoryType="unsigned8" encodedType="bitfield6" comment="The crank wheel tooth, on crank sense 1, that schedules spark3"/>
        <Data name="spark1sense2tooth" inMemoryType="unsigned8" encodedType="bitfield6" comment="The crank wheel tooth, on crank sense 2, that schedules spark1"/>
        <Data name="spark2sense2tooth" inMemoryType="unsigned8" encodedType="bitfield6" comment="The crank wheel tooth, on crank sense 2, that schedules spark2"/>
        <Data name="spark3sense2tooth" inMemoryType="unsigned8" encodedType="bitfield6" comment="The crank wheel tooth, on crank sense 2, that schedules spark3"/>
        <Data name="injector1sense1tooth" inMemoryType="unsigned8" encodedType="bitfield6" comment="The crank wheel tooth, on crank sense 1, that schedules injector1"/>
        <Data name="injector2sense1tooth" inMemoryType="unsigned8" encodedType="bitfield6" comment="The crank wheel tooth, on crank sense 1, that schedules injector2"/>
        <Data name="injector3sense1tooth" inMemoryType="unsigned8" encodedType="bitfield6" comment="The crank wheel tooth, on crank sense 1, that schedules injector3"/>
        <Data name="injector1sense2tooth" inMemoryType="unsigned8" encodedType="bitfield6" comment="The crank wheel tooth, on crank sense 2, that schedules injector1"/>
        <Data name="injector2sense2tooth" inMemoryType="unsigned8" encodedType="bitfield6" comment="The crank wheel tooth, on crank sense 2, that schedules injector2"/>
        <Data name="injector3sense2tooth" inMemoryType="unsigned8" encodedType="bitfield6" comment="The crank wheel tooth, on crank sense 2, that schedules injector3"/>

        <Data name="revcountsincestart" inMemoryType="unsigned32" encodedType="unsigned24" scaler="1.0/256.0" comment="Number of revolutions since the engine started"/>
        <Data name="secondssincestart" inMemoryType="unsigned32" encodedType="unsigned24" comment="Seconds since the engine started"/>

    </Packet>

</Protocol>
